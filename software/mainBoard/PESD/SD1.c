/* ###################################################################
**     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
**     Filename    : SD1.c
**     Project     : SPITest
**     Processor   : MKL26Z128VMC4
**     Component   : SD_Card
**     Version     : Component 01.153, Driver 01.00, CPU db: 3.00.000
**     Compiler    : GNU C Compiler
**     Date/Time   : 2015-09-28, 23:23, # CodeGen: 3
**     Abstract    :
**
**     Settings    :
**
**     Contents    :
**         Init             - byte SD1_Init(void* unused);
**         Deinit           - void SD1_Deinit(void* unused);
**         Activate         - void SD1_Activate(void);
**         Deactivate       - void SD1_Deactivate(void);
**         isWriteProtected - bool SD1_isWriteProtected(void);
**         CardPresent      - bool SD1_CardPresent(void);
**         WaitReady        - byte SD1_WaitReady(void);
**         ReceiveDataBlock - bool SD1_ReceiveDataBlock(byte *data, word nofBytes);
**         SendDataBlock    - bool SD1_SendDataBlock(byte *data, byte token, word nofBytes);
**         SendCmd          - byte SD1_SendCmd(byte cmd, dword arg);
**         SetFastMode      - void SD1_SetFastMode(void);
**         InitCommChannel  - void SD1_InitCommChannel(void);
**
**     License   :  Open Source (LGPL)
**     Copyright : (c) Copyright Erich Styger, 2012, all rights reserved.
**     This an open source software implementing an SD card low level driver useful for the the ChaN FatFS, using Processor Expert.
**     This is a free software and is opened for education,  research and commercial developments under license policy of following terms:
**     * This is a free software and there is NO WARRANTY.
**     * No restriction on use. You can use, modify and redistribute it for personal, non-profit or commercial product UNDER YOUR RESPONSIBILITY.
**     * Redistributions of source code must retain the above copyright notice.
** ###################################################################*/
/*!
** @file SD1.c
** @version 01.00
** @brief
**
*/         
/*!
**  @addtogroup SD1_module SD1 module documentation
**  @{
*/         

/* MODULE SD1. */

#include "SD1.h"
#include "diskio.h"

static volatile DSTATUS Stat = STA_NOINIT; /* Disk status */
static uint8_t CardType = CT_SD1;       /* Card type flags */

enum { /* SD card response codes */
  SD1_OK = 0,
  SD1_IDLE = 1
};

/* different wait counters to deal with slow SD cards */
#define SD1_TIMEOUT_READY_MS       500  /* user configured wait timeout until the device is ready */
#define SD1_TIMEOUT_CMD_MS         100  /* user configured wait timeout for commands */
#define SD1_TIMEOUT_READ_BLOCK_MS  500  /* user configured wait timeout for reading a data block */
#define SD1_ENABLE_SS()   SS1_ClrVal(SS1_DeviceData) /* enable slave (low active) */
#define SD1_DISABLE_SS()  SS1_SetVal(SS1_DeviceData) /* disable slave (low active) */
#define SD1_DUMMY 0xff /* SPI dummy value */

/*-----------------------------------------------------------------------*/
/* Initialize a Drive                                                    */
DSTATUS disk_initialize (
        uint8_t drv                     /* Physical drive number (0..) */
)
{
  uint8_t n, cmd, ty, ocr[4];

  if (drv!=0) return STA_NOINIT;        /* Supports only single drive */
  if (Stat & STA_NODISK) return Stat;   /* No card in the socket */
  if (SD1_Init(NULL) != ERR_OK) {
    return STA_NOINIT;
  }
  ty = 0;
  if (SD1_SendCmd(SD1_CMD0, 0) == 1) {  /* Enter Idle state */
    if (SD1_SendCmd(SD1_CMD8, 0x1AA) == 1) { /* SDHC */
      for (n = 0; n < 4; n++) {
        ocr[n] = SD1_ReceiveByte();     /* Get trailing return value of R7 resp */
      }
      if (ocr[2] == 0x01 && ocr[3] == 0xAA) { /* The card can work at vdd range of 2.7-3.6V */
        while (SD1_SendCmd(SD1_ACMD41, 1UL << 30)) {
          /* Wait for leaving idle state (ACMD41 with HCS bit) */
        }
        if (SD1_SendCmd(SD1_CMD58, 0) == 0) { /* Check CCS bit in the OCR */
          for (n = 0; n < 4; n++) {
            ocr[n] = SD1_ReceiveByte();
          }
          ty = (uint8_t)((ocr[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2); /* SDv2 */
        }
      }
    } else {                            /* SDSC or MMC */
      if (SD1_SendCmd(SD1_ACMD41, 0) <= 1) {
        ty = CT_SD1; cmd = SD1_ACMD41;  /* SDv1 */
      } else {
        ty = CT_MMC; cmd = SD1_CMD1;    /* MMCv3 */
      }
      while (SD1_SendCmd(cmd, 0)) {
        /* Wait for leaving idle state */
      }
      if (SD1_SendCmd(SD1_CMD16, SD1_BLOCK_SIZE) != 0) { /* Set R/W block length  */
        ty = 0;
      }
    }
    SD1_SetFastMode();
  }
  CardType = ty;
  Stat &= ~STA_NOINIT;                  /* Clear STA_NOINIT */
  return Stat;
}

/*-----------------------------------------------------------------------*/
/* Return Disk Status                                                    */
DSTATUS disk_status (
        uint8_t drv                     /* Physical drive nmuber (0..) */
)
{
  if (drv!=0) return STA_NOINIT;        /* Supports only single drive */
  return Stat;
}

/*-----------------------------------------------------------------------*/
/* Read Sector(s)                                                        */
DRESULT disk_read (
        uint8_t drv,                    /* Physical drive number (0..) */
        uint8_t *buff,                  /* Data buffer to store read data */
        uint32_t sector,                /* Sector address (LBA) */
        uint8_t count                   /* Number of sectors to read (1..255) */
)
{
  if (drv!=0 || !count) return RES_PARERR;
  if (Stat & STA_NOINIT) return RES_NOTRDY;
  if (!(CardType & CT_BLOCK)) {
    sector *= SD1_BLOCK_SIZE;           /* Convert to byte address if needed */
  }
  if (count == 1) {                     /* Single block read */
    if (   (SD1_SendCmd(SD1_CMD17, sector) == 0) /* READ_SINGLE_BLOCK */
        && SD1_ReceiveDataBlock(buff, SD1_BLOCK_SIZE))
    {
      count = 0;
    }
  } else {                              /* Multiple block read */
    if (SD1_SendCmd(SD1_CMD18, sector) == 0) { /* READ_MULTIPLE_BLOCK */
      do {
        if (!SD1_ReceiveDataBlock(buff, SD1_BLOCK_SIZE)) {
          break;
        }
        buff += SD1_BLOCK_SIZE;
      } while (--count);
      (void)SD1_SendCmd(SD1_CMD12, 0);  /* STOP_TRANSMISSION */
    }
  }
  return count ? RES_ERROR : RES_OK;
}

/*-----------------------------------------------------------------------*/
/* Write Sector(s)                                                       */
#if _READONLY == 0
DRESULT disk_write (
        uint8_t drv,                    /* Physical drive number (0..) */
        const uint8_t *buff,            /* Data to be written */
        uint32_t sector,                /* Sector address (LBA) */
        uint8_t count                   /* Number of sectors to write (1..255) */
)
{
  if (drv!=0 || !count) return RES_PARERR;
  if (Stat & STA_NOINIT) return RES_NOTRDY;
  if (Stat & STA_PROTECT) return RES_WRPRT;
  if (!(CardType & CT_BLOCK)) {
    sector *= SD1_BLOCK_SIZE;           /* Convert to byte address if needed */
  }
  if (count == 1) {                     /* Single block write */
    if (  (SD1_SendCmd(SD1_CMD24, sector) == 0) /* WRITE_BLOCK */
        && SD1_SendDataBlock((byte*)buff, 0xFE, SD1_BLOCK_SIZE))
    {
      count = 0;
    }
  } else {                              /* Multiple block write */
    if (CardType & CT_SDC) {
      (void)SD1_SendCmd(SD1_ACMD23, count);
    }
    if (SD1_SendCmd(SD1_CMD25, sector) == 0) { /* WRITE_MULTIPLE_BLOCK */
      do {
        if (!SD1_SendDataBlock((byte*)buff, 0xFC, SD1_BLOCK_SIZE)) {
          break;
        }
        buff += SD1_BLOCK_SIZE;
      } while (--count);
      if (!SD1_SendDataBlock(0, 0xFD, SD1_BLOCK_SIZE)) { /* STOP_TRAN token */
        count = 1;
      }
    }
  }
  return count ? RES_ERROR : RES_OK;
}
#endif /* _READONLY */
/*-----------------------------------------------------------------------*/
/* Miscellaneous Functions                                               */
static bool chk_power(void) { return 1;}
static void power_off(void) {}
static void power_on(void) {}
/*-----------------------------------------------------------------------*/
DRESULT disk_ioctl (
        uint8_t drv,                    /* Physical drive number (0..) */
        uint8_t ctrl,                   /* Control code */
        void *buff                      /* Buffer to send/receive control data */
)
{
  DRESULT res = RES_OK;
  uint8_t n, csd[16], *ptr = buff;
  uint16_t csize;

  if (drv!=0) return RES_PARERR;
  if (ctrl == CTRL_POWER) {
    switch (*ptr) {
      case 0:                           /* Sub control code == 0 (POWER_OFF) */
        if (chk_power()) {
          power_off();                  /* Power off */
        }
        break;
      case 1:                           /* Sub control code == 1 (POWER_ON) */
        power_on();                     /* Power on */
        break;
      case 2:                           /* Sub control code == 2 (POWER_GET) */
        *(ptr+1) = (uint8_t)chk_power();
        break;
      default:
        res = RES_PARERR;
    } /* switch */
  } else {
    if (Stat & STA_NOINIT) {
      return RES_NOTRDY;
    }
    switch (ctrl) {
      case CTRL_SYNC :                  /* Make sure that no pending write process. Do not remove this or written sector might not left updated. */
        SD1_Activate();
        if (SD1_WaitReady() != ERR_OK) {
          res = RES_ERROR;
        }
        break;
      case MMC_GET_READ_BL_LEN:         /* get Block Length */
        if ((SD1_SendCmd(SD1_CMD9, 0) == 0) && SD1_ReceiveDataBlock(csd, 16)) {
          switch((csd[5]&15)) {         /* READ_BL_LEN is either 9, 10 or 11, end the block size is 2^READ_BL_LEN */
            case 9: *(uint16_t*)ptr = 512; break;
            case 10: *(uint16_t*)ptr = 1024; break;
            case 11: *(uint16_t*)ptr = 2048; break;
            default: *(uint16_t*)ptr = 0; break; /* illegal */
          }
        }
        break;
      case MMC_GET_SDC_VERSION:         /* get CSD Version (1 byte: 1 for 1.xx or MMC, 2 for 2.0 */
        if ((SD1_SendCmd(SD1_CMD9, 0) == 0) && SD1_ReceiveDataBlock(csd, 16)) {
          if ((csd[0] >> 6) == 1) {     /* SDC ver 2.00 */
            *ptr = 2;
          } else {                      /* SDC ver 1.XX or MMC*/
            *ptr = 1;
          }
        }
        break;
      case GET_SECTOR_COUNT :           /* Get number of sectors on the disk (uint32_t) */
        if ((SD1_SendCmd(SD1_CMD9, 0) == 0) && SD1_ReceiveDataBlock(csd, 16)) {
          if ((csd[0] >> 6) == 1) {     /* SDC ver 2.00 */
            csize = (uint16_t)(csd[9] + ((uint16_t)csd[8] << 8) + 1);
            *(uint32_t*)buff = (uint32_t)csize << 10;
          } else {                      /* SDC ver 1.XX or MMC*/
            n = (uint8_t)((csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2);
            csize = (uint16_t)((csd[8] >> 6) + ((uint16_t)csd[7] << 2) + ((uint16_t)(csd[6] & 3) << 10) + 1);
            *(uint32_t*)buff = (uint32_t)csize << (byte)(n - 9);
          }
        }
        break;
      case GET_SECTOR_SIZE :            /* Get R/W sector size (uint16_t) */
        *(uint16_t*)buff = SD1_BLOCK_SIZE;
        break;
      case GET_BLOCK_SIZE :             /* Get erase block size in unit of sector (uint32_t) */
        if (CardType & CT_SD2) {        /* SDC ver 2.00 */
          if (SD1_SendCmd(SD1_ACMD13, 0) == 0) { /* Read SD status */
            (void)SD1_ReceiveByte();
            if (SD1_ReceiveDataBlock(csd, 16)) { /* Read partial block */
              for (n = 64 - 16; n; n--) {
                (void)SD1_ReceiveByte(); /* Purge trailing data */
              }
              *(uint32_t*)buff = 16UL << (csd[10] >> 4);
            }
          }
        } else {                        /* SDC ver 1.XX or MMC */
          if ((SD1_SendCmd(SD1_CMD9, 0) == 0) && SD1_ReceiveDataBlock(csd, 16)) {        /* Read CSD */
            if (CardType & CT_SD1) {    /* SDC ver 1.XX */
              *(uint32_t*)buff = (uint32_t)((((csd[10] & 63) << 1) + ((uint16_t)(csd[11] & 128) >> 7) + 1) << (byte)((csd[13] >> 6) - 1));
            } else {                    /* MMC */
              *(uint32_t*)buff = (uint32_t)(((uint16_t)((csd[10] & 124) >> 2) + 1) * (((csd[11] & 3) << 3) + ((csd[11] & 224) >> 5) + 1));
            }
          }
        }
        break;
      case MMC_GET_TYPE :               /* Get card type flags (1 byte) */
        *ptr = CardType;
        break;

      case MMC_GET_CSD :                /* Receive CSD as a data block (16 bytes) */
         if (!(SD1_SendCmd(SD1_CMD9, 0) == 0 /* READ_CSD */
            && SD1_ReceiveDataBlock(ptr, 16)))
         {
           res = RES_PARERR;
         }
         break;
      case MMC_GET_CID :                /* Receive CID as a data block (16 bytes) */
        if (!(SD1_SendCmd(SD1_CMD10, 0) == 0 /* READ_CID */
            && SD1_ReceiveDataBlock(ptr, 16)))
        {
          res = RES_PARERR;
        }
        break;

      case MMC_GET_OCR :                /* Receive OCR as an R3 resp (4 bytes) */
        if (SD1_SendCmd(SD1_CMD58, 0) == 0) { /* READ_OCR */
          for (n = 4; n; n--) {
            *ptr++ = SD1_ReceiveByte();
          }
        } else {
          res = RES_PARERR;
        }
        break;

      case MMC_GET_SDSTAT :             /* Receive SD status as a data block (64 bytes) */
        if (SD1_SendCmd(SD1_ACMD13, 0) == 0) { /* SD_STATUS */
          (void)SD1_ReceiveByte();
          if (!SD1_ReceiveDataBlock(ptr, 64)) {
            res = RES_PARERR;
          }
        } else {
          res = RES_PARERR;
        }
        break;

      case MMC_GET_DRIVER_VERSION:      /* 1 byte: return: 0 SPI driver, 1 LLD SDHC driver */
        *ptr = 0;
        break;

      default:
        res = RES_PARERR;
    } /* switch */
    SD1_Deactivate();
  }
  return res;
}

#define SD1_SPI_SetSlowMode()              (void)SM2_SelectConfiguration(SM2_DeviceData, 0, 0) /* max 400kbps */
#define SD1_SPI_SetFastMode()              (void)SM2_SelectConfiguration(SM2_DeviceData, 1, 1) /* max 12Mbps */
#define SD1_SPI_SetShiftClockPolarity(val) /* not needed for LDD */
#define SD1_SPI_SetIdleClockPolarity(val)  /* not needed for LDD */

bool SD1_DataReceivedFlag = FALSE;

void SD1_SPI_WRITE(unsigned char write) {
  unsigned char dummy;

  SD1_DataReceivedFlag = FALSE;
  (void)SM2_ReceiveBlock(SM2_DeviceData, &dummy, sizeof(dummy));
  (void)SM2_SendBlock(SM2_DeviceData, &write, sizeof(write));
  while(!SD1_DataReceivedFlag){}
}

void SD1_SPI_WRITE_READ(unsigned char write, unsigned char *readP) {
  SD1_DataReceivedFlag = FALSE;
  (void)SM2_ReceiveBlock(SM2_DeviceData, readP, 1);
  (void)SM2_SendBlock(SM2_DeviceData, &write, 1);
  while(!SD1_DataReceivedFlag){}
}



/* Internal method prototypes */
static byte SendCommand(byte cmd, byte *arg, byte response);

/*
** ===================================================================
**     Method      :  SD1_Activate (component SD_Card)
**     Description :
**         If multiple devices are used on the same SPI bus, then the
**         device needs to be activated. That way, the different SPI
**         protocol is selected.
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void SD1_Activate(void)
{
  /* Note that the SD card SPI interface is defined with 'clock idle low polarity' and 'data shift on rising edge',
   * typically defined as well as 'Mode 0' (CPHA=0, CPOL=0). See http://elm-chan.org/docs/mmc/mmc_e.html
   */
  SD1_InitCommChannel();
  SD1_ENABLE_SS();                      /* select slave */
}

/*
** ===================================================================
**     Method      :  SD1_Deactivate (component SD_Card)
**     Description :
**         Removes/deactivates the card from the bus
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void SD1_Deactivate(void)
{
  SD1_DISABLE_SS();
}

/*
** ===================================================================
**     Method      :  SD1_WaitReady (component SD_Card)
**     Description :
**         Wait until the card is ready
**     Parameters  : None
**     Returns     :
**         ---             - Error code
**                           ERR_OK: device is ready
**                           ERR_BUSY: device is still busy
** ===================================================================
*/
byte SD1_WaitReady(void)
{
  byte tmp;
  TMOUT1_CounterHandle timeout;

  SD1_SPI_WRITE(SD1_DUMMY);
  timeout = TMOUT1_GetCounter(SD1_TIMEOUT_READY_MS/TMOUT1_TICK_PERIOD_MS); /* set up timeout counter */
  for (;;) {                            /* will timeout */
    SD1_SPI_WRITE_READ(SD1_DUMMY, &tmp); /* write dummy value, read status */
    if (tmp==0xff) {
      break;
    }
    if (TMOUT1_CounterExpired(timeout)) {
      break;
    }
  } /* for */
  TMOUT1_LeaveCounter(timeout);
  if (tmp==0xff) {
    return ERR_OK; /* device is ready */
  } else {
    return ERR_BUSY;
  }
}

/*
** ===================================================================
**     Method      :  SD1_ReceiveDataBlock (component SD_Card)
**     Description :
**         Retrieve a data block from the device
**     Parameters  :
**         NAME            - DESCRIPTION
**       * data            - Pointer to data buffer
**         nofBytes        - number of bytes to retrieve,
**                           must be a multiple of 4
**     Returns     :
**         ---             - TRUE if reading was going fine, FALSE
**                           otherwise.
** ===================================================================
*/
bool SD1_ReceiveDataBlock(byte *data, word nofBytes)
{
  byte tmp;
  TMOUT1_CounterHandle timeout;
  word cnt = 512; /* polling counter */

  /* poll response */
  do {
    SD1_SPI_WRITE_READ(SD1_DUMMY, &tmp); /* send dummy value, poll response */
    cnt--;
  } while (tmp==0xFF && cnt>0);
  if (tmp==0xFF) { /* polling not successful, now poll for a longer period of time */
    timeout = TMOUT1_GetCounter(SD1_TIMEOUT_READ_BLOCK_MS/TMOUT1_TICK_PERIOD_MS); /* timeout */
    for (;;) {                          /* will timeout */
      SD1_SPI_WRITE_READ(SD1_DUMMY, &tmp); /* send dummy value, poll response */
      if (tmp!=0xFF) {
        break;
      }
      if (TMOUT1_CounterExpired(timeout)) {
        break;
      }
    } /* for */
    TMOUT1_LeaveCounter(timeout);
  } /* if */
  if (tmp != 0xFE) {                    /* if it is not expected response, return with error */
    return FALSE;
  }
  while(nofBytes>0) {
    SD1_SPI_WRITE_READ(SD1_DUMMY, data); /* write dummy value, read data */
    data++;
    nofBytes--;
  }
  SD1_SPI_WRITE(SD1_DUMMY);             /* checksum Bytes not needed */
  SD1_SPI_WRITE(SD1_DUMMY);
  return TRUE;
}

/*
** ===================================================================
**     Method      :  SD1_SendDataBlock (component SD_Card)
**     Description :
**         Send a data block to the device
**     Parameters  :
**         NAME            - DESCRIPTION
**       * data            - Pointer to data blocks with 512 bytes
**                           each
**         token           - data/stop token
**         nofBytes        - Number of bytes to send
**     Returns     :
**         ---             - Returns TRUE for success, FALSE for
**                           failure.
** ===================================================================
*/
bool SD1_SendDataBlock(byte *data, byte token, word nofBytes)
{
  byte resp;

  if (SD1_WaitReady()!=ERR_OK) {
    return FALSE;                       /* device not ready */
  }
  SD1_SPI_WRITE(token);                 /* Xmit data token */
  if (token != 0xFD) {                  /* Is data token, not STOP_TRAN */
    while (nofBytes!=0) {               /* send the bytes */
      SD1_SPI_WRITE(*data);
      data++;
      nofBytes--;
    }
    SD1_SPI_WRITE(SD1_DUMMY);           /* CRC (Dummy) */
    SD1_SPI_WRITE(SD1_DUMMY);           /* CRC (Dummy) */
    SD1_SPI_WRITE_READ(SD1_DUMMY, &resp); /* write dummy value, receive data response */
    if ((resp&0x1F) != 0x05) {          /* If not accepted, return with error */
      return FALSE;
    }
    /* if we do not poll the device for its busy state, we need to provide at least 8 clocks (dummy cycle).
     * See http://elm-chan.org/docs/mmc/mmc_e.html:
     *    In principle of the SPI mode, the CS signal must be asserted during a transaction,
     *    however there is an exception to this rule. When the card is busy, the host controller
     *    can deassert CS to release SPI bus for any other SPI devices. The card will drive DO signal
     *    low again when reselect it during internal process is in progress.
     *    Therefore a preceding busy check (wait ready immediately before command and data packet)
     *    instead of post wait can eliminate waste wait time. In addition the internal process is initiated
     *    a byte after the data response, this means eight clocks are required to initiate internal write operation.
     */
    SD1_SPI_WRITE(SD1_DUMMY);
  }
  return TRUE;
}

/*
** ===================================================================
**     Method      :  SD1_SendCmd (component SD_Card)
**     Description :
**         Sends a command to the device and returns the response
**     Parameters  :
**         NAME            - DESCRIPTION
**         cmd             - Command to send
**         arg             - command argument
**     Returns     :
**         ---             - device response
** ===================================================================
*/
byte SD1_SendCmd(byte cmd, dword arg)
{
  byte n, res;
  TMOUT1_CounterHandle timeout;

  if (cmd&0x80) {                       /* ACMD<n> is the command sequence of CMD55-CMD<n> */
    cmd &= 0x7F;
    res = SD1_SendCmd(SD1_CMD55, 0);
    if (res > 1) {
      return res;
    }
  }
  /* Select the card and wait for ready */
  SD1_Activate();
  if (SD1_WaitReady() != ERR_OK) {
    return 0xFF;
  }
  /* Send command packet */
  SD1_SPI_WRITE(cmd);                   /* Start + Command index */
  n = (byte)(arg>>24);
  SD1_SPI_WRITE(n);                     /* Argument[31..24] */
  n = (byte)(arg>>16);
  SD1_SPI_WRITE(n);                     /* Argument[23..16] */
  n = (byte)(arg>>8);
  SD1_SPI_WRITE(n);                     /* Argument[15..8] */
  SD1_SPI_WRITE((byte)arg);             /* Argument[7..0] */
  if (cmd == SD1_CMD0) {
    n = 0x95;                           /* Valid CRC for CMD0(0) */
  } else if (cmd == SD1_CMD8) {
    n = 0x87;                           /* Valid CRC for CMD8(0x1AA) */
  } else {
    n = 0x01;                           /* Dummy CRC + Stop */
  }
  SD1_SPI_WRITE(n);

  /* Receive command response */
  if (cmd == SD1_CMD12) {
    SD1_SPI_WRITE_READ(SD1_DUMMY, &res); /* send dummy value, poll response */
  }
  timeout = TMOUT1_GetCounter(SD1_TIMEOUT_CMD_MS/TMOUT1_TICK_PERIOD_MS); /* timeout */
  for(;;) {                            /* will timeout */
    SD1_SPI_WRITE_READ(SD1_DUMMY, &res); /* send dummy value, poll response */
    if (!(res&0x80)) {                 /* valid response */
      break;
    }
    if (TMOUT1_CounterExpired(timeout)) {
      break;
    }
  }
  TMOUT1_LeaveCounter(timeout);
  return res;                           /* Return with the response value */
}
/*
** ===================================================================
**     Method      :  SD1_isWriteProtected (component SD_Card)
**     Description :
**         Determines if the card is write protected. Note that this is
**         an indicator only, as it is still possible to write to the
**         card even if the write protection is set on the card!
**     Parameters  : None
**     Returns     :
**         ---             - True if the card has the write protection
**                           set, false otherwise
** ===================================================================
*/
/*
bool SD1_isWriteProtected(void)
{
  *** method is implemented as macro in the header file
}
*/

/*
** ===================================================================
**     Method      :  SendCommand (component SD_Card)
**
**     Description :
**         Sends a command to the SD card
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static byte SendCommand(byte cmd, byte *arg, byte response)
{
  #define NOF_WAIT_ITERATIONS 3
  byte u8Temp=0;
  byte u8Counter;

  SD1_SPI_WRITE(cmd);                   /* Send Start byte */
  /* Send Argument */
  for(u8Counter=0; u8Counter<4; u8Counter++) {
    SD1_SPI_WRITE(arg[u8Counter]);
  }
  SD1_SPI_WRITE(0x95);                  /* Send CRC */
  /* Response Handler */
  for (u8Counter=0;u8Counter<NOF_WAIT_ITERATIONS;u8Counter++) {
    SD1_SPI_WRITE_READ(SD1_DUMMY, &u8Temp); /* send dummy value, poll response */
    if (u8Temp==response) {
      break;
    }
  } /* for */
  if (u8Temp==response) {
    return ERR_OK;
  } else {
    return ERR_FAULT;
  }
}

/*
** ===================================================================
**     Method      :  SD1_Init (component SD_Card)
**     Description :
**         Initializes the driver
**     Parameters  :
**         NAME            - DESCRIPTION
**       * unused          - unused parameter
**     Returns     :
**         ---             - Error code
** ===================================================================
*/
byte SD1_Init(void* unused)
{
  /* The behavior of SD cards in SPI mode is basically the same as for any SPI slave device.
     The maximum transfer rate of the SD card in SPI mode is 25 Mbps, but in the initialization process the
     transfer rate must be less than 375 kbps. This is because the SPI mode of the SD cards is compatible with
     the MMC cards, and MMC cards can only reach 375 kbps. After initialization, the SPI clock can be
     changed to 25 Mbps.
     Note that the SPI interface is defined with 'clock idle low polarity' and 'data shift on rising edge',
     typically defined as well as 'Mode 0' (CPHA=0, CPOL=0). See http://elm-chan.org/docs/mmc/mmc_e.html
   */
  dword arg;
  TMOUT1_CounterHandle timeout;
  bool isTimeout = FALSE;
  byte cnt;

  (void)unused;
  /* -------------------------------- Init & Slow Mode -------------------------------- */
  /* after voltage reaches 2.2V, need to wait at least 1 ms. Then we need to set Data and CS/Chipselect high for at least 74 clocks */
  WAIT1_Waitms(1);                      /* wait at least for 1 ms on insertion and power on */
  SD1_Activate();                       /* activate card (configure SPI) and select device */
  SD1_SPI_SetSlowMode();                /* set the SPI clock to 375 kbps. This is required for compatibility across a wide range of SD and MMC cards. */
  SD1_DISABLE_SS();                     /* disable slave (CS high) */
  for(cnt=0;cnt<10;cnt++) {             /* send at least 75 SPI clock cycles with the SS signal asserted to ensure that the SD card internal state machine is initialized. */
    SD1_SPI_WRITE(SD1_DUMMY);
  }
  WAIT1_Waitus(50);                     /* need to wait a little bin in order SPI transfer to be finished (need this on CN128, but on others too?) */
  SD1_ENABLE_SS();                      /* select slave */
  /* -------------------------------- IDLE Command -------------------------------- */
  arg = 0;
  timeout = TMOUT1_GetCounter(SD1_TIMEOUT_READY_MS/TMOUT1_TICK_PERIOD_MS); /* timeout */
  while (SendCommand(SD1_CMD0, (byte*)&arg, SD1_IDLE) != ERR_OK) {
    if (TMOUT1_CounterExpired(timeout)) {
      isTimeout = TRUE;                /* indicate a timeout */
      break;
    }
  } /* while */
  TMOUT1_LeaveCounter(timeout);
  SD1_DISABLE_SS();                     /* disable slave */
  if (isTimeout) {                     /* timeout */
    return ERR_FAULT;
  }
  /* Send 8 SPI clocks (SS unasserted). */
  SD1_SPI_WRITE(SD1_DUMMY);             /* dummy SPI cycle */
  SD1_ENABLE_SS();                      /* select slave */
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  SD1_ReceiveByte (component SD_Card)
**
**     Description :
**         Receives a byte from the SPI bus
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
byte SD1_ReceiveByte(void)
{
  byte data;

  SD1_SPI_WRITE_READ(SD1_DUMMY, &data); /* send dummy value, poll response */
  return data;
}

/*
** ===================================================================
**     Method      :  SD1_CardPresent (component SD_Card)
**     Description :
**         Returns true in case a card is present. If there is no card
**         detection pin, then this routine will always return true.
**     Parameters  : None
**     Returns     :
**         ---             - Returns true if card is present, false
**                           otherwise.
** ===================================================================
*/
/*
bool SD1_CardPresent(void)
{
  *** method is implemented as macro in the header file
}
*/

/*
** ===================================================================
**     Method      :  SD1_SetFastMode (component SD_Card)
**     Description :
**         Switches to fast mode SPI communication speed.
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void SD1_SetFastMode(void)
{
  SD1_SPI_SetFastMode();                /* the SPI clock is set to the maximum supported by the MCU and allowed by the SD card */
}

/*
** ===================================================================
**     Method      :  SD1_InitCommChannel (component SD_Card)
**     Description :
**         Method to initialize the communication channel. This is
**         needed if the bus to the SD card is shared with other
**         devices.
**     Parameters  : None
**     Returns     : Nothing
** ===================================================================
*/
void SD1_InitCommChannel(void)
{
  /* Settings:
    - 100-400 kHz clock during init, then max 12 MHz
    - Send MSB first
    - Shift clock idle polarity: low
    - Clock edge: falling edge
  */
  SD1_SPI_SetFastMode(); /* use fast mode. This will use the fast configuration. */
}

/*
** ===================================================================
**     Method      :  SD1_Deinit (component SD_Card)
**     Description :
**         Driver deinitialization routine.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * unused          - 
**     Returns     : Nothing
** ===================================================================
*/
void SD1_Deinit(void* unused)
{
  (void)unused;
}

/* END SD1. */

/*!
** @}
*/
/*
** ###################################################################
**
**     This file was created by Processor Expert 10.4 [05.09]
**     for the Freescale Kinetis series of microcontrollers.
**
** ###################################################################
*/
