   1               		.file	"usitwislave.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 111               	set_sda_to_input:
 112               		.stabd	46,0,0
   1:usitwislave.c **** /*	See LICENSE for Copyright etc. */
   2:usitwislave.c **** 
   3:usitwislave.c **** #include <avr/io.h>
   4:usitwislave.c **** #include <avr/interrupt.h>
   5:usitwislave.c **** #include <avr/sleep.h>
   6:usitwislave.c **** 
   7:usitwislave.c **** #include "usitwislave_devices.h"
   8:usitwislave.c **** #include "usitwislave.h"
   9:usitwislave.c **** 
  10:usitwislave.c **** enum
  11:usitwislave.c **** {
  12:usitwislave.c **** 	of_state_check_address,
  13:usitwislave.c **** 	of_state_send_data,
  14:usitwislave.c **** 	of_state_request_ack,
  15:usitwislave.c **** 	of_state_check_ack,
  16:usitwislave.c **** 	of_state_receive_data,
  17:usitwislave.c **** 	of_state_store_data_and_send_ack
  18:usitwislave.c **** } overflow_state_t;
  19:usitwislave.c **** 
  20:usitwislave.c **** enum
  21:usitwislave.c **** {
  22:usitwislave.c **** 	ss_state_before_start,
  23:usitwislave.c **** 	ss_state_after_start,
  24:usitwislave.c **** 	ss_state_address_selected,
  25:usitwislave.c **** 	ss_state_address_not_selected,
  26:usitwislave.c **** 	ss_state_data_processed
  27:usitwislave.c **** } startstop_state_t;
  28:usitwislave.c **** 
  29:usitwislave.c **** static void (*idle_callback)(void);
  30:usitwislave.c **** static void	(*data_callback)(uint8_t *input_buffer_length, const uint8_t *input_buffer,
  31:usitwislave.c **** 						uint8_t *output_buffer_length, uint8_t *output_buffer);
  32:usitwislave.c **** 
  33:usitwislave.c **** static uint8_t of_state;
  34:usitwislave.c **** static uint8_t ss_state;
  35:usitwislave.c **** 
  36:usitwislave.c **** static uint8_t	slave_address;
  37:usitwislave.c **** 
  38:usitwislave.c **** static uint8_t	input_buffer[USI_TWI_BUFFER_SIZE];
  39:usitwislave.c **** static uint8_t	input_buffer_length;
  40:usitwislave.c **** static uint8_t	output_buffer[USI_TWI_BUFFER_SIZE];
  41:usitwislave.c **** static uint8_t	output_buffer_length;
  42:usitwislave.c **** static uint8_t	output_buffer_current;
  43:usitwislave.c **** 
  44:usitwislave.c **** static uint8_t	stats_enabled;
  45:usitwislave.c **** static uint16_t	start_conditions_count;
  46:usitwislave.c **** static uint16_t	stop_conditions_count;
  47:usitwislave.c **** static uint16_t	error_conditions_count;
  48:usitwislave.c **** static uint16_t	overflow_conditions_count;
  49:usitwislave.c **** static uint16_t	local_frames_count;
  50:usitwislave.c **** static uint16_t	idle_call_count;
  51:usitwislave.c **** 
  52:usitwislave.c **** static void set_sda_to_input(void)
  53:usitwislave.c **** {
 114               	.LM0:
 115               	.LFBB1:
 116               	/* prologue: function */
 117               	/* frame size = 0 */
 118               	/* stack size = 0 */
 119               	.L__stack_usage = 0
  54:usitwislave.c **** 	DDR_USI &= ~_BV(PORT_USI_SDA);
 121               	.LM1:
 122 0000 D698      		cbi 0x1a,6
 123 0002 0895      		ret
 125               	.Lscope1:
 127               		.stabd	78,0,0
 130               	set_sda_to_output:
 131               		.stabd	46,0,0
  55:usitwislave.c **** }
  56:usitwislave.c **** 
  57:usitwislave.c **** static void set_sda_to_output(void)
  58:usitwislave.c **** {
 133               	.LM2:
 134               	.LFBB2:
 135               	/* prologue: function */
 136               	/* frame size = 0 */
 137               	/* stack size = 0 */
 138               	.L__stack_usage = 0
  59:usitwislave.c **** 	DDR_USI |= _BV(PORT_USI_SDA);
 140               	.LM3:
 141 0004 D69A      		sbi 0x1a,6
 142 0006 0895      		ret
 144               	.Lscope2:
 146               		.stabd	78,0,0
 149               	twi_reset:
 150               		.stabd	46,0,0
  60:usitwislave.c **** }
  61:usitwislave.c **** 
  62:usitwislave.c **** static inline void set_scl_to_input(void)
  63:usitwislave.c **** {
  64:usitwislave.c **** 	DDR_USI &= ~_BV(PORT_USI_SCL);
  65:usitwislave.c **** }
  66:usitwislave.c **** 
  67:usitwislave.c **** static inline void set_scl_to_output(void)
  68:usitwislave.c **** {
  69:usitwislave.c **** 	DDR_USI |= _BV(PORT_USI_SCL);
  70:usitwislave.c **** }
  71:usitwislave.c **** 
  72:usitwislave.c **** static inline void set_sda_low(void)
  73:usitwislave.c **** {
  74:usitwislave.c **** 	PORT_USI &= ~_BV(PORT_USI_SDA);
  75:usitwislave.c **** }
  76:usitwislave.c **** 
  77:usitwislave.c **** static inline void set_sda_high(void)
  78:usitwislave.c **** {
  79:usitwislave.c **** 	PORT_USI |= _BV(PORT_USI_SDA);
  80:usitwislave.c **** }
  81:usitwislave.c **** 
  82:usitwislave.c **** static inline void set_scl_low(void)
  83:usitwislave.c **** {
  84:usitwislave.c **** 	PORT_USI &= ~_BV(PORT_USI_SCL);
  85:usitwislave.c **** }
  86:usitwislave.c **** 
  87:usitwislave.c **** static inline void set_scl_high(void)
  88:usitwislave.c **** {
  89:usitwislave.c **** 	PORT_USI |= _BV(PORT_USI_SCL);
  90:usitwislave.c **** }
  91:usitwislave.c **** 
  92:usitwislave.c **** static inline void twi_reset_state(void)
  93:usitwislave.c **** {
  94:usitwislave.c **** 	USISR =
  95:usitwislave.c **** 		(1		<< USISIF)	|		// clear start condition flag
  96:usitwislave.c **** 		(1		<< USIOIF)	|		// clear overflow condition flag
  97:usitwislave.c **** 		(0		<< USIPF)	|		// !clear stop condition flag
  98:usitwislave.c **** 		(1		<< USIDC)	|		// clear arbitration error flag
  99:usitwislave.c **** 		(0x00	<< USICNT0);		// set counter to "8" bits
 100:usitwislave.c **** 
 101:usitwislave.c **** 	USICR =
 102:usitwislave.c **** 		(1 << USISIE) |									// enable start condition interrupt
 103:usitwislave.c **** 		(0 << USIOIE) |									// !enable overflow interrupt
 104:usitwislave.c **** 		(1 << USIWM1) | (0 << USIWM0) |					// set usi in two-wire mode, disable bit counter overflow hol
 105:usitwislave.c **** 		(1 << USICS1) | (0 << USICS0) | (0 << USICLK) |	// shift register clock source = external, positi
 106:usitwislave.c **** 		(0 << USITC);									// don't toggle clock-port pin
 107:usitwislave.c **** }
 108:usitwislave.c **** 
 109:usitwislave.c **** static void twi_reset(void)
 110:usitwislave.c **** {
 152               	.LM4:
 153               	.LFBB3:
 154               	/* prologue: function */
 155               	/* frame size = 0 */
 156               	/* stack size = 0 */
 157               	.L__stack_usage = 0
 111:usitwislave.c **** 	// make sure no sda/scl remains pulled up or down
 112:usitwislave.c **** 
 113:usitwislave.c **** 	set_sda_to_input();		//	deactivate internal pullup on sda/scl
 159               	.LM5:
 160 0008 00D0      		rcall set_sda_to_input
 161               	.LBB20:
 162               	.LBB21:
  74:usitwislave.c **** }
 164               	.LM6:
 165 000a DE98      		cbi 0x1b,6
 166               	.LBE21:
 167               	.LBE20:
 168               	.LBB22:
 169               	.LBB23:
  64:usitwislave.c **** }
 171               	.LM7:
 172 000c D498      		cbi 0x1a,4
 173               	.LBE23:
 174               	.LBE22:
 175               	.LBB24:
 176               	.LBB25:
  84:usitwislave.c **** }
 178               	.LM8:
 179 000e DC98      		cbi 0x1b,4
 180               	.LBE25:
 181               	.LBE24:
 114:usitwislave.c **** 	set_sda_low();
 115:usitwislave.c **** 	set_scl_to_input();
 116:usitwislave.c **** 	set_scl_low();
 117:usitwislave.c **** 
 118:usitwislave.c **** 	set_sda_to_output();	//	release (set high) on sda/scl
 183               	.LM9:
 184 0010 00D0      		rcall set_sda_to_output
 185               	.LBB26:
 186               	.LBB27:
  79:usitwislave.c **** }
 188               	.LM10:
 189 0012 DE9A      		sbi 0x1b,6
 190               	.LBE27:
 191               	.LBE26:
 119:usitwislave.c **** 	set_sda_high();
 120:usitwislave.c **** 	set_sda_to_input();
 193               	.LM11:
 194 0014 00D0      		rcall set_sda_to_input
 195               	.LBB28:
 196               	.LBB29:
  79:usitwislave.c **** }
 198               	.LM12:
 199 0016 DE9A      		sbi 0x1b,6
 200               	.LBE29:
 201               	.LBE28:
 202               	.LBB30:
 203               	.LBB31:
  69:usitwislave.c **** }
 205               	.LM13:
 206 0018 D49A      		sbi 0x1a,4
 207               	.LBE31:
 208               	.LBE30:
 209               	.LBB32:
 210               	.LBB33:
  89:usitwislave.c **** }
 212               	.LM14:
 213 001a DC9A      		sbi 0x1b,4
 214               	.LBE33:
 215               	.LBE32:
 216               	.LBB34:
 217               	.LBB35:
  94:usitwislave.c **** 		(1		<< USISIF)	|		// clear start condition flag
 219               	.LM15:
 220 001c 80ED      		ldi r24,lo8(-48)
 221 001e 8EB9      		out 0xe,r24
 101:usitwislave.c **** 		(1 << USISIE) |									// enable start condition interrupt
 223               	.LM16:
 224 0020 88EA      		ldi r24,lo8(-88)
 225 0022 8DB9      		out 0xd,r24
 226 0024 0895      		ret
 227               	.LBE35:
 228               	.LBE34:
 230               	.Lscope3:
 232               		.stabd	78,0,0
 234               	.global	__vector_15
 236               	__vector_15:
 237               		.stabd	46,0,0
 121:usitwislave.c **** 	set_sda_high();
 122:usitwislave.c **** 	set_scl_to_output();
 123:usitwislave.c **** 	set_scl_high();
 124:usitwislave.c **** 
 125:usitwislave.c **** 	twi_reset_state();
 126:usitwislave.c **** }
 127:usitwislave.c **** 
 128:usitwislave.c **** static inline void twi_init(void)
 129:usitwislave.c **** {
 130:usitwislave.c **** #if defined(USIPP)
 131:usitwislave.c **** #if  defined(USI_ON_PORT_A)
 132:usitwislave.c **** 	USIPP |= _BV(USIPOS);
 133:usitwislave.c **** #else
 134:usitwislave.c **** 	USIPP &= ~_BV(USIPOS);
 135:usitwislave.c **** # endif
 136:usitwislave.c **** #endif
 137:usitwislave.c **** 
 138:usitwislave.c **** 	twi_reset();
 139:usitwislave.c **** }
 140:usitwislave.c **** 
 141:usitwislave.c **** ISR(USI_START_vect)
 142:usitwislave.c **** {
 239               	.LM17:
 240               	.LFBB4:
 241 0026 1F92      		push r1
 242 0028 0F92      		push r0
 243 002a 0FB6      		in r0,__SREG__
 244 002c 0F92      		push r0
 245 002e 1124      		clr __zero_reg__
 246 0030 2F93      		push r18
 247 0032 3F93      		push r19
 248 0034 4F93      		push r20
 249 0036 5F93      		push r21
 250 0038 6F93      		push r22
 251 003a 7F93      		push r23
 252 003c 8F93      		push r24
 253 003e 9F93      		push r25
 254 0040 AF93      		push r26
 255 0042 BF93      		push r27
 256 0044 EF93      		push r30
 257 0046 FF93      		push r31
 258               	/* prologue: Signal */
 259               	/* frame size = 0 */
 260               	/* stack size = 15 */
 261               	.L__stack_usage = 15
 143:usitwislave.c **** 	set_sda_to_input();
 263               	.LM18:
 264 0048 00D0      		rcall set_sda_to_input
 265               	.L5:
 144:usitwislave.c **** 
 145:usitwislave.c **** 	// wait for SCL to go low to ensure the start condition has completed (the
 146:usitwislave.c **** 	// start detector will hold SCL low) - if a stop condition arises then leave
 147:usitwislave.c **** 	// the interrupt to prevent waiting forever - don't use USISR to test for stop
 148:usitwislave.c **** 	// condition as in Application Note AVR312 because the stop condition Flag is
 149:usitwislave.c **** 	// going to be set from the last TWI sequence
 150:usitwislave.c **** 
 151:usitwislave.c **** 	while(!(PIN_USI & _BV(PIN_USI_SDA)) &&
 267               	.LM19:
 268 004a CE99      		sbic 0x19,6
 269 004c 00C0      		rjmp .L7
 271               	.LM20:
 272 004e CC9B      		sbis 0x19,4
 273 0050 00C0      		rjmp .L7
 152:usitwislave.c **** 			(PIN_USI & _BV(PIN_USI_SCL)))
 153:usitwislave.c **** 
 154:usitwislave.c **** 	// possible combinations
 155:usitwislave.c **** 	//	sda = low	scl = low		break	start condition
 156:usitwislave.c **** 	// 	sda = low	scl = high		loop
 157:usitwislave.c **** 	//	sda = high	scl = low		break	stop condition
 158:usitwislave.c **** 	//	sda = high	scl = high		break	stop condition
 159:usitwislave.c **** 
 160:usitwislave.c **** 	if((PIN_USI & _BV(PIN_USI_SDA)))	// stop condition
 275               	.LM21:
 276 0052 CE9B      		sbis 0x19,6
 277 0054 00C0      		rjmp .L5
 161:usitwislave.c **** 	{
 162:usitwislave.c **** 		twi_reset();
 279               	.LM22:
 280 0056 00D0      		rcall twi_reset
 163:usitwislave.c **** 
 164:usitwislave.c **** 		if(stats_enabled)
 282               	.LM23:
 283 0058 8091 0000 		lds r24,stats_enabled
 284 005c 8823      		tst r24
 285 005e 01F0      		breq .L4
 165:usitwislave.c **** 			error_conditions_count++;
 287               	.LM24:
 288 0060 8091 0000 		lds r24,error_conditions_count
 289 0064 9091 0000 		lds r25,error_conditions_count+1
 290 0068 0196      		adiw r24,1
 291 006a 9093 0000 		sts error_conditions_count+1,r25
 292 006e 8093 0000 		sts error_conditions_count,r24
 293 0072 00C0      		rjmp .L4
 294               	.L7:
 166:usitwislave.c **** 		return;
 167:usitwislave.c **** 	}
 168:usitwislave.c **** 
 169:usitwislave.c **** 	if(stats_enabled)
 296               	.LM25:
 297 0074 8091 0000 		lds r24,stats_enabled
 298 0078 8823      		tst r24
 299 007a 01F0      		breq .L9
 170:usitwislave.c **** 		start_conditions_count++;
 301               	.LM26:
 302 007c 8091 0000 		lds r24,start_conditions_count
 303 0080 9091 0000 		lds r25,start_conditions_count+1
 304 0084 0196      		adiw r24,1
 305 0086 9093 0000 		sts start_conditions_count+1,r25
 306 008a 8093 0000 		sts start_conditions_count,r24
 307               	.L9:
 171:usitwislave.c **** 
 172:usitwislave.c **** 	of_state = of_state_check_address;
 309               	.LM27:
 310 008e 1092 0000 		sts of_state,__zero_reg__
 173:usitwislave.c **** 	ss_state = ss_state_after_start;
 312               	.LM28:
 313 0092 81E0      		ldi r24,lo8(1)
 314 0094 8093 0000 		sts ss_state,r24
 174:usitwislave.c **** 
 175:usitwislave.c **** 	USIDR = 0xff;
 316               	.LM29:
 317 0098 8FEF      		ldi r24,lo8(-1)
 318 009a 8FB9      		out 0xf,r24
 176:usitwislave.c **** 
 177:usitwislave.c **** 	USICR =
 320               	.LM30:
 321 009c 88EF      		ldi r24,lo8(-8)
 322 009e 8DB9      		out 0xd,r24
 178:usitwislave.c **** 		(1 << USISIE) |									// enable start condition interrupt
 179:usitwislave.c **** 		(1 << USIOIE) |									// enable overflow interrupt
 180:usitwislave.c **** 		(1 << USIWM1) | (1 << USIWM0) |					// set usi in two-wire mode, enable bit counter overflow hold
 181:usitwislave.c **** 		(1 << USICS1) | (0 << USICS0) | (0 << USICLK) |	// shift register clock source = external, positi
 182:usitwislave.c **** 		(0 << USITC);									// don't toggle clock-port pin
 183:usitwislave.c **** 
 184:usitwislave.c **** 	USISR =
 324               	.LM31:
 325 00a0 80ED      		ldi r24,lo8(-48)
 326 00a2 8EB9      		out 0xe,r24
 327               	.L4:
 328               	/* epilogue start */
 185:usitwislave.c **** 		(1		<< USISIF)	|		// clear start condition flag
 186:usitwislave.c **** 		(1		<< USIOIF)	|		// clear overflow condition flag
 187:usitwislave.c **** 		(0		<< USIPF)	|		// !clear stop condition flag
 188:usitwislave.c **** 		(1		<< USIDC)	|		// clear arbitration error flag
 189:usitwislave.c **** 		(0x00	<< USICNT0);		// set counter to "8" bits
 190:usitwislave.c **** }
 330               	.LM32:
 331 00a4 FF91      		pop r31
 332 00a6 EF91      		pop r30
 333 00a8 BF91      		pop r27
 334 00aa AF91      		pop r26
 335 00ac 9F91      		pop r25
 336 00ae 8F91      		pop r24
 337 00b0 7F91      		pop r23
 338 00b2 6F91      		pop r22
 339 00b4 5F91      		pop r21
 340 00b6 4F91      		pop r20
 341 00b8 3F91      		pop r19
 342 00ba 2F91      		pop r18
 343 00bc 0F90      		pop r0
 344 00be 0FBE      		out __SREG__,r0
 345 00c0 0F90      		pop r0
 346 00c2 1F90      		pop r1
 347 00c4 1895      		reti
 349               	.Lscope4:
 351               		.stabd	78,0,0
 353               	.global	__vector_16
 355               	__vector_16:
 356               		.stabd	46,0,0
 191:usitwislave.c **** 
 192:usitwislave.c **** ISR(USI_OVERFLOW_VECTOR)
 193:usitwislave.c **** {
 358               	.LM33:
 359               	.LFBB5:
 360 00c6 1F92      		push r1
 361 00c8 0F92      		push r0
 362 00ca 0FB6      		in r0,__SREG__
 363 00cc 0F92      		push r0
 364 00ce 1124      		clr __zero_reg__
 365 00d0 2F93      		push r18
 366 00d2 3F93      		push r19
 367 00d4 4F93      		push r20
 368 00d6 5F93      		push r21
 369 00d8 6F93      		push r22
 370 00da 7F93      		push r23
 371 00dc 8F93      		push r24
 372 00de 9F93      		push r25
 373 00e0 AF93      		push r26
 374 00e2 BF93      		push r27
 375 00e4 EF93      		push r30
 376 00e6 FF93      		push r31
 377               	/* prologue: Signal */
 378               	/* frame size = 0 */
 379               	/* stack size = 15 */
 380               	.L__stack_usage = 15
 194:usitwislave.c **** 	// bit shift register overflow condition occured
 195:usitwislave.c **** 	// scl forced low until overflow condition is cleared!
 196:usitwislave.c **** 
 197:usitwislave.c **** 	uint8_t data		= USIDR;
 382               	.LM34:
 383 00e8 9FB1      		in r25,0xf
 198:usitwislave.c **** 	uint8_t set_counter = 0x00;		// send 8 bits (16 edges)
 199:usitwislave.c **** 
 200:usitwislave.c **** 	if(stats_enabled)
 385               	.LM35:
 386 00ea 8091 0000 		lds r24,stats_enabled
 387 00ee 8823      		tst r24
 388 00f0 01F0      		breq .L20
 201:usitwislave.c **** 		overflow_conditions_count++;
 390               	.LM36:
 391 00f2 2091 0000 		lds r18,overflow_conditions_count
 392 00f6 3091 0000 		lds r19,overflow_conditions_count+1
 393 00fa 2F5F      		subi r18,-1
 394 00fc 3F4F      		sbci r19,-1
 395 00fe 3093 0000 		sts overflow_conditions_count+1,r19
 396 0102 2093 0000 		sts overflow_conditions_count,r18
 397               	.L20:
 202:usitwislave.c **** 
 203:usitwislave.c **** again:
 204:usitwislave.c **** 	switch(of_state)
 399               	.LM37:
 400 0106 8091 0000 		lds r24,of_state
 401 010a 8230      		cpi r24,lo8(2)
 402 010c 01F4      		brne .+2
 403 010e 00C0      		rjmp .L22
 404 0110 00F4      		brsh .L23
 405 0112 8823      		tst r24
 406 0114 01F0      		breq .L24
 407 0116 8130      		cpi r24,lo8(1)
 408 0118 01F0      		breq .+2
 409 011a 00C0      		rjmp .L35
 410 011c 00C0      		rjmp .L25
 411               	.L23:
 412 011e 8430      		cpi r24,lo8(4)
 413 0120 01F4      		brne .+2
 414 0122 00C0      		rjmp .L26
 415 0124 00F4      		brsh .+2
 416 0126 00C0      		rjmp .L27
 417 0128 8530      		cpi r24,lo8(5)
 418 012a 01F4      		brne .+2
 419 012c 00C0      		rjmp .L28
 420 012e 00C0      		rjmp .L35
 421               	.L24:
 422               	.LBB39:
 205:usitwislave.c **** 	{
 206:usitwislave.c **** 		// start condition occured and succeed
 207:usitwislave.c **** 		// check address, if not OK, reset usi
 208:usitwislave.c **** 		// note: not using general call address
 209:usitwislave.c **** 
 210:usitwislave.c **** 		case(of_state_check_address):
 211:usitwislave.c **** 		{
 212:usitwislave.c **** 			uint8_t address;
 213:usitwislave.c **** 			uint8_t direction;
 214:usitwislave.c **** 
 215:usitwislave.c **** 			direction	= data & 0x01;
 216:usitwislave.c **** 			address		= (data & 0xfe) >> 1;
 217:usitwislave.c **** 
 218:usitwislave.c **** 			if(address == slave_address)
 424               	.LM38:
 425 0130 2091 0000 		lds r18,slave_address
 426 0134 892F      		mov r24,r25
 427 0136 8695      		lsr r24
 428 0138 8213      		cpse r24,r18
 429 013a 00C0      		rjmp .L29
 219:usitwislave.c **** 			{
 220:usitwislave.c **** 				ss_state = ss_state_address_selected;
 431               	.LM39:
 432 013c 82E0      		ldi r24,lo8(2)
 433 013e 8093 0000 		sts ss_state,r24
 221:usitwislave.c **** 
 222:usitwislave.c **** 	/*PORTA ^= (1<<7);        //Use xor to toggle the LED*/
 223:usitwislave.c **** 				if(direction)					// read request from master
 435               	.LM40:
 436 0142 90FF      		sbrs r25,0
 437 0144 00C0      		rjmp .L30
 224:usitwislave.c **** 					of_state = of_state_send_data;
 439               	.LM41:
 440 0146 81E0      		ldi r24,lo8(1)
 441 0148 00C0      		rjmp .L45
 442               	.L30:
 225:usitwislave.c **** 				else							// write request from master
 226:usitwislave.c **** 					of_state = of_state_receive_data;
 444               	.LM42:
 445 014a 84E0      		ldi r24,lo8(4)
 446               	.L45:
 447 014c 8093 0000 		sts of_state,r24
 448               	.L47:
 227:usitwislave.c **** 
 228:usitwislave.c **** 				USIDR		= 0x00;
 450               	.LM43:
 451 0150 1FB8      		out 0xf,__zero_reg__
 229:usitwislave.c **** 				set_counter = 0x0e;				// send 1 bit (2 edges)
 230:usitwislave.c **** 				set_sda_to_output();			// initiate send ack
 453               	.LM44:
 454 0152 00D0      		rcall set_sda_to_output
 455 0154 00C0      		rjmp .L46
 456               	.L29:
 231:usitwislave.c **** 			}
 232:usitwislave.c **** 			else
 233:usitwislave.c **** 			{
 234:usitwislave.c **** 				USIDR		= 0x00;
 458               	.LM45:
 459 0156 1FB8      		out 0xf,__zero_reg__
 460               	.LBB40:
 461               	.LBB41:
  94:usitwislave.c **** 		(1		<< USISIF)	|		// clear start condition flag
 463               	.LM46:
 464 0158 80ED      		ldi r24,lo8(-48)
 465 015a 8EB9      		out 0xe,r24
 101:usitwislave.c **** 		(1 << USISIE) |									// enable start condition interrupt
 467               	.LM47:
 468 015c 88EA      		ldi r24,lo8(-88)
 469 015e 8DB9      		out 0xd,r24
 470               	.LBE41:
 471               	.LBE40:
 235:usitwislave.c **** 				set_counter = 0x00;
 236:usitwislave.c **** 				twi_reset_state();
 237:usitwislave.c **** 				ss_state = ss_state_address_not_selected;
 473               	.LM48:
 474 0160 83E0      		ldi r24,lo8(3)
 475 0162 8093 0000 		sts ss_state,r24
 476 0166 00C0      		rjmp .L35
 477               	.L25:
 478               	.LBE39:
 238:usitwislave.c **** 			}
 239:usitwislave.c **** 
 240:usitwislave.c **** 			break;
 241:usitwislave.c **** 		}
 242:usitwislave.c **** 
 243:usitwislave.c **** 		// process read request from master
 244:usitwislave.c **** 
 245:usitwislave.c **** 		case(of_state_send_data):
 246:usitwislave.c **** 		{
 247:usitwislave.c **** 			ss_state = ss_state_data_processed;
 480               	.LM49:
 481 0168 84E0      		ldi r24,lo8(4)
 482 016a 8093 0000 		sts ss_state,r24
 248:usitwislave.c **** 			of_state = of_state_request_ack;
 484               	.LM50:
 485 016e 82E0      		ldi r24,lo8(2)
 486 0170 8093 0000 		sts of_state,r24
 249:usitwislave.c **** 
 250:usitwislave.c **** 			if(output_buffer_current < output_buffer_length)
 488               	.LM51:
 489 0174 E091 0000 		lds r30,output_buffer_current
 490 0178 8091 0000 		lds r24,output_buffer_length
 491 017c E817      		cp r30,r24
 492 017e 00F4      		brsh .L32
 251:usitwislave.c **** 				USIDR = output_buffer[output_buffer_current++];
 494               	.LM52:
 495 0180 81E0      		ldi r24,lo8(1)
 496 0182 8E0F      		add r24,r30
 497 0184 8093 0000 		sts output_buffer_current,r24
 498 0188 F0E0      		ldi r31,0
 499 018a E050      		subi r30,lo8(-(output_buffer))
 500 018c F040      		sbci r31,hi8(-(output_buffer))
 501 018e 8081      		ld r24,Z
 502 0190 8FB9      		out 0xf,r24
 503 0192 00C0      		rjmp .L33
 504               	.L32:
 252:usitwislave.c **** 			else
 253:usitwislave.c **** 				USIDR = 0x00;					// no more data, but cannot send "nothing" or "nak"
 506               	.LM53:
 507 0194 1FB8      		out 0xf,__zero_reg__
 508               	.L33:
 254:usitwislave.c **** 
 255:usitwislave.c **** 			set_counter = 0x00;
 256:usitwislave.c **** 			set_sda_to_output();				// initiate send data
 510               	.LM54:
 511 0196 00D0      		rcall set_sda_to_output
 512 0198 00C0      		rjmp .L35
 513               	.L22:
 257:usitwislave.c **** 
 258:usitwislave.c **** 			break;
 259:usitwislave.c **** 		}
 260:usitwislave.c **** 
 261:usitwislave.c **** 		// data sent to master, request ack (or nack) from master
 262:usitwislave.c **** 
 263:usitwislave.c **** 		case(of_state_request_ack):
 264:usitwislave.c **** 		{
 265:usitwislave.c **** 			of_state = of_state_check_ack;
 515               	.LM55:
 516 019a 83E0      		ldi r24,lo8(3)
 517 019c 8093 0000 		sts of_state,r24
 266:usitwislave.c **** 
 267:usitwislave.c **** 			USIDR		= 0x00;
 519               	.LM56:
 520 01a0 1FB8      		out 0xf,__zero_reg__
 268:usitwislave.c **** 			set_counter = 0x0e;					//	receive 1 bit (2 edges)
 269:usitwislave.c **** 			set_sda_to_input();					//	initiate receive ack
 522               	.LM57:
 523 01a2 00D0      		rcall set_sda_to_input
 524               	.L46:
 268:usitwislave.c **** 			set_counter = 0x0e;					//	receive 1 bit (2 edges)
 526               	.LM58:
 527 01a4 8EE0      		ldi r24,lo8(14)
 270:usitwislave.c **** 
 271:usitwislave.c **** 			break;
 529               	.LM59:
 530 01a6 00C0      		rjmp .L21
 531               	.L27:
 272:usitwislave.c **** 		}
 273:usitwislave.c **** 
 274:usitwislave.c **** 		// ack/nack from master received
 275:usitwislave.c **** 
 276:usitwislave.c **** 		case(of_state_check_ack):
 277:usitwislave.c **** 		{
 278:usitwislave.c **** 			if(data)	// if NACK, the master does not want more data
 533               	.LM60:
 534 01a8 9923      		tst r25
 535 01aa 01F0      		breq .L25
 279:usitwislave.c **** 			{
 280:usitwislave.c **** 				of_state = of_state_check_address;
 537               	.LM61:
 538 01ac 1092 0000 		sts of_state,__zero_reg__
 281:usitwislave.c **** 				set_counter = 0x00;
 282:usitwislave.c **** 				twi_reset();
 540               	.LM62:
 541 01b0 00D0      		rcall twi_reset
 542 01b2 00C0      		rjmp .L35
 543               	.L26:
 283:usitwislave.c **** 			}
 284:usitwislave.c **** 			else
 285:usitwislave.c **** 			{
 286:usitwislave.c **** 				of_state = of_state_send_data;
 287:usitwislave.c **** 				goto again;	// from here we just drop straight into state_send_data
 288:usitwislave.c **** 			}				// don't wait for another overflow interrupt
 289:usitwislave.c **** 
 290:usitwislave.c **** 			break;
 291:usitwislave.c **** 		}
 292:usitwislave.c **** 
 293:usitwislave.c **** 		// process write request from master
 294:usitwislave.c **** 
 295:usitwislave.c **** 		case(of_state_receive_data):
 296:usitwislave.c **** 		{
 297:usitwislave.c **** 			ss_state = ss_state_data_processed;
 545               	.LM63:
 546 01b4 8093 0000 		sts ss_state,r24
 298:usitwislave.c **** 
 299:usitwislave.c **** 			of_state = of_state_store_data_and_send_ack;
 548               	.LM64:
 549 01b8 85E0      		ldi r24,lo8(5)
 550 01ba 8093 0000 		sts of_state,r24
 300:usitwislave.c **** 
 301:usitwislave.c **** 			set_counter = 0x00;					// receive 1 bit (2 edges)
 302:usitwislave.c **** 			set_sda_to_input();					// initiate receive data
 552               	.LM65:
 553 01be 00D0      		rcall set_sda_to_input
 554 01c0 00C0      		rjmp .L35
 555               	.L28:
 303:usitwislave.c **** 
 304:usitwislave.c **** 			break;
 305:usitwislave.c **** 		}
 306:usitwislave.c **** 
 307:usitwislave.c **** 		// data received from master, store it and wait for more data
 308:usitwislave.c **** 
 309:usitwislave.c **** 		case(of_state_store_data_and_send_ack):
 310:usitwislave.c **** 		{
 311:usitwislave.c **** 			of_state = of_state_receive_data;
 557               	.LM66:
 558 01c2 84E0      		ldi r24,lo8(4)
 559 01c4 8093 0000 		sts of_state,r24
 312:usitwislave.c **** 
 313:usitwislave.c **** 			if(input_buffer_length < (USI_TWI_BUFFER_SIZE - 1))
 561               	.LM67:
 562 01c8 E091 0000 		lds r30,input_buffer_length
 563 01cc EF31      		cpi r30,lo8(31)
 564 01ce 00F0      		brlo .+2
 565 01d0 00C0      		rjmp .L47
 314:usitwislave.c **** 				input_buffer[input_buffer_length++] = data;
 567               	.LM68:
 568 01d2 81E0      		ldi r24,lo8(1)
 569 01d4 8E0F      		add r24,r30
 570 01d6 8093 0000 		sts input_buffer_length,r24
 571 01da F0E0      		ldi r31,0
 572 01dc E050      		subi r30,lo8(-(input_buffer))
 573 01de F040      		sbci r31,hi8(-(input_buffer))
 574 01e0 9083      		st Z,r25
 575 01e2 00C0      		rjmp .L47
 576               	.L35:
 198:usitwislave.c **** 
 578               	.LM69:
 579 01e4 80E0      		ldi r24,0
 580               	.L21:
 315:usitwislave.c **** 
 316:usitwislave.c **** 			USIDR		= 0x00;
 317:usitwislave.c **** 			set_counter = 0x0e;					// send 1 bit (2 edges)
 318:usitwislave.c **** 			set_sda_to_output();				// initiate send ack
 319:usitwislave.c **** 
 320:usitwislave.c **** 			break;
 321:usitwislave.c **** 		}
 322:usitwislave.c **** 	}
 323:usitwislave.c **** 
 324:usitwislave.c **** 	USISR =
 325:usitwislave.c **** 		(0				<< USISIF)	|		// don't clear start condition flag
 326:usitwislave.c **** 		(1				<< USIOIF)	|		// clear overflow condition flag
 327:usitwislave.c **** 		(0				<< USIPF)	|		// don't clear stop condition flag
 328:usitwislave.c **** 		(1				<< USIDC)	|		// clear arbitration error flag
 582               	.LM70:
 583 01e6 8065      		ori r24,lo8(80)
 324:usitwislave.c **** 		(0				<< USISIF)	|		// don't clear start condition flag
 585               	.LM71:
 586 01e8 8EB9      		out 0xe,r24
 587               	/* epilogue start */
 329:usitwislave.c **** 		(set_counter	<< USICNT0);		// set counter to 8 or 1 bits
 330:usitwislave.c **** }
 589               	.LM72:
 590 01ea FF91      		pop r31
 591 01ec EF91      		pop r30
 592 01ee BF91      		pop r27
 593 01f0 AF91      		pop r26
 594 01f2 9F91      		pop r25
 595 01f4 8F91      		pop r24
 596 01f6 7F91      		pop r23
 597 01f8 6F91      		pop r22
 598 01fa 5F91      		pop r21
 599 01fc 4F91      		pop r20
 600 01fe 3F91      		pop r19
 601 0200 2F91      		pop r18
 602 0202 0F90      		pop r0
 603 0204 0FBE      		out __SREG__,r0
 604 0206 0F90      		pop r0
 605 0208 1F90      		pop r1
 606 020a 1895      		reti
 612               	.Lscope5:
 614               		.stabd	78,0,0
 620               	.global	usi_twi_slave
 622               	usi_twi_slave:
 623               		.stabd	46,0,0
 331:usitwislave.c **** 
 332:usitwislave.c **** void usi_twi_slave(uint8_t slave_address_in, uint8_t use_sleep,
 333:usitwislave.c **** 			void (*data_callback_in)(volatile uint8_t *input_buffer_length, volatile const uint8_t *input_bu
 334:usitwislave.c **** 			volatile uint8_t *output_buffer_length, volatile uint8_t *output_buffer),
 335:usitwislave.c **** 			void (*idle_callback_in)(void))
 336:usitwislave.c **** {
 625               	.LM73:
 626               	.LFBB6:
 627               	/* prologue: function */
 628               	/* frame size = 0 */
 629               	/* stack size = 0 */
 630               	.L__stack_usage = 0
 631 020c C62F      		mov r28,r22
 337:usitwislave.c **** 	uint8_t	call_datacallback = 0;
 338:usitwislave.c **** 
 339:usitwislave.c **** 	slave_address			= slave_address_in;
 633               	.LM74:
 634 020e 8093 0000 		sts slave_address,r24
 340:usitwislave.c **** 	data_callback			= data_callback_in;
 636               	.LM75:
 637 0212 5093 0000 		sts data_callback+1,r21
 638 0216 4093 0000 		sts data_callback,r20
 341:usitwislave.c **** 	idle_callback			= idle_callback_in;
 640               	.LM76:
 641 021a 3093 0000 		sts idle_callback+1,r19
 642 021e 2093 0000 		sts idle_callback,r18
 342:usitwislave.c **** 
 343:usitwislave.c **** 	input_buffer_length		= 0;
 644               	.LM77:
 645 0222 1092 0000 		sts input_buffer_length,__zero_reg__
 344:usitwislave.c **** 	output_buffer_length	= 0;
 647               	.LM78:
 648 0226 1092 0000 		sts output_buffer_length,__zero_reg__
 345:usitwislave.c **** 	output_buffer_current	= 0;
 650               	.LM79:
 651 022a 1092 0000 		sts output_buffer_current,__zero_reg__
 346:usitwislave.c **** 	ss_state				= ss_state_before_start;
 653               	.LM80:
 654 022e 1092 0000 		sts ss_state,__zero_reg__
 347:usitwislave.c **** 
 348:usitwislave.c **** 	if(use_sleep)
 656               	.LM81:
 657 0232 6623      		tst r22
 658 0234 01F0      		breq .L49
 349:usitwislave.c **** 		set_sleep_mode(SLEEP_MODE_IDLE);
 660               	.LM82:
 661 0236 85B7      		in r24,0x35
 662 0238 877E      		andi r24,lo8(-25)
 663 023a 85BF      		out 0x35,r24
 664               	.L49:
 665               	.LBB42:
 666               	.LBB43:
 138:usitwislave.c **** }
 668               	.LM83:
 669 023c 00D0      		rcall twi_reset
 670               	.LBE43:
 671               	.LBE42:
 350:usitwislave.c **** 
 351:usitwislave.c **** 	twi_init();
 352:usitwislave.c **** 
 353:usitwislave.c **** 	sei();
 673               	.LM84:
 674               	/* #APP */
 675               	 ;  353 "usitwislave.c" 1
 676 023e 7894      		sei
 677               	 ;  0 "" 2
 678               	/* #NOAPP */
 679               	.L54:
 354:usitwislave.c **** 	for(;;)
 355:usitwislave.c **** 	{
 356:usitwislave.c **** 		if(idle_callback)
 681               	.LM85:
 682 0240 E091 0000 		lds r30,idle_callback
 683 0244 F091 0000 		lds r31,idle_callback+1
 684 0248 3097      		sbiw r30,0
 685 024a 01F0      		breq .L51
 357:usitwislave.c **** 		{
 358:usitwislave.c **** 
 359:usitwislave.c **** 			idle_callback();
 687               	.LM86:
 688 024c 0995      		icall
 360:usitwislave.c **** 
 361:usitwislave.c **** 			if(stats_enabled)
 690               	.LM87:
 691 024e 8091 0000 		lds r24,stats_enabled
 692 0252 8823      		tst r24
 693 0254 01F0      		breq .L51
 362:usitwislave.c **** 				idle_call_count++;
 695               	.LM88:
 696 0256 8091 0000 		lds r24,idle_call_count
 697 025a 9091 0000 		lds r25,idle_call_count+1
 698 025e 0196      		adiw r24,1
 699 0260 9093 0000 		sts idle_call_count+1,r25
 700 0264 8093 0000 		sts idle_call_count,r24
 701               	.L51:
 363:usitwislave.c **** 		}
 364:usitwislave.c **** 
 365:usitwislave.c **** 		if(use_sleep && (ss_state == ss_state_before_start))
 703               	.LM89:
 704 0268 CC23      		tst r28
 705 026a 01F0      		breq .L53
 707               	.LM90:
 708 026c 8091 0000 		lds r24,ss_state
 709 0270 8111      		cpse r24,__zero_reg__
 710 0272 00C0      		rjmp .L53
 366:usitwislave.c **** 			sleep_mode();
 712               	.LM91:
 713 0274 85B7      		in r24,0x35
 714 0276 8062      		ori r24,lo8(32)
 715 0278 85BF      		out 0x35,r24
 716               	/* #APP */
 717               	 ;  366 "usitwislave.c" 1
 718 027a 8895      		sleep
 719               		
 720               	 ;  0 "" 2
 721               	/* #NOAPP */
 722 027c 85B7      		in r24,0x35
 723 027e 8F7D      		andi r24,lo8(-33)
 724 0280 85BF      		out 0x35,r24
 725               	.L53:
 367:usitwislave.c **** 
 368:usitwislave.c **** 		if(USISR & _BV(USIPF))
 727               	.LM92:
 728 0282 759B      		sbis 0xe,5
 729 0284 00C0      		rjmp .L54
 369:usitwislave.c **** 		{
 370:usitwislave.c **** 			cli();
 731               	.LM93:
 732               	/* #APP */
 733               	 ;  370 "usitwislave.c" 1
 734 0286 F894      		cli
 735               	 ;  0 "" 2
 371:usitwislave.c **** 
 372:usitwislave.c **** 			if(stats_enabled)
 737               	.LM94:
 738               	/* #NOAPP */
 739 0288 8091 0000 		lds r24,stats_enabled
 740 028c 8823      		tst r24
 741 028e 01F0      		breq .L55
 373:usitwislave.c **** 				stop_conditions_count++;
 743               	.LM95:
 744 0290 8091 0000 		lds r24,stop_conditions_count
 745 0294 9091 0000 		lds r25,stop_conditions_count+1
 746 0298 0196      		adiw r24,1
 747 029a 9093 0000 		sts stop_conditions_count+1,r25
 748 029e 8093 0000 		sts stop_conditions_count,r24
 749               	.L55:
 374:usitwislave.c **** 
 375:usitwislave.c **** 			USISR |= _BV(USIPF);	// clear stop condition flag
 751               	.LM96:
 752 02a2 759A      		sbi 0xe,5
 376:usitwislave.c **** 
 377:usitwislave.c **** 			switch(ss_state)
 754               	.LM97:
 755 02a4 8091 0000 		lds r24,ss_state
 756 02a8 8130      		cpi r24,lo8(1)
 757 02aa 01F0      		breq .L57
 758 02ac 8430      		cpi r24,lo8(4)
 759 02ae 01F0      		breq .L58
 760 02b0 00C0      		rjmp .L79
 761               	.L57:
 378:usitwislave.c **** 			{
 379:usitwislave.c **** 				case(ss_state_after_start):
 380:usitwislave.c **** 				{
 381:usitwislave.c **** 					twi_reset();
 763               	.LM98:
 764 02b2 00D0      		rcall twi_reset
 765 02b4 00C0      		rjmp .L79
 766               	.L58:
 382:usitwislave.c **** 					break;
 383:usitwislave.c **** 				}
 384:usitwislave.c **** 
 385:usitwislave.c **** 				case(ss_state_data_processed):
 386:usitwislave.c **** 				{
 387:usitwislave.c **** 					if(stats_enabled)
 768               	.LM99:
 769 02b6 8091 0000 		lds r24,stats_enabled
 770 02ba 8823      		tst r24
 771 02bc 01F0      		breq .L62
 388:usitwislave.c **** 						local_frames_count++;
 773               	.LM100:
 774 02be 8091 0000 		lds r24,local_frames_count
 775 02c2 9091 0000 		lds r25,local_frames_count+1
 776 02c6 0196      		adiw r24,1
 777 02c8 9093 0000 		sts local_frames_count+1,r25
 778 02cc 8093 0000 		sts local_frames_count,r24
 779 02d0 00C0      		rjmp .L62
 780               	.L79:
 377:usitwislave.c **** 			{
 782               	.LM101:
 783 02d2 80E0      		ldi r24,0
 784 02d4 00C0      		rjmp .L56
 785               	.L62:
 389:usitwislave.c **** 
 390:usitwislave.c **** 					call_datacallback = 1;
 787               	.LM102:
 788 02d6 81E0      		ldi r24,lo8(1)
 789               	.L56:
 391:usitwislave.c **** 
 392:usitwislave.c **** 					break;
 393:usitwislave.c **** 				}
 394:usitwislave.c **** 			}
 395:usitwislave.c **** 
 396:usitwislave.c **** 			ss_state = ss_state_before_start;
 791               	.LM103:
 792 02d8 1092 0000 		sts ss_state,__zero_reg__
 397:usitwislave.c **** 
 398:usitwislave.c **** 			sei();
 794               	.LM104:
 795               	/* #APP */
 796               	 ;  398 "usitwislave.c" 1
 797 02dc 7894      		sei
 798               	 ;  0 "" 2
 399:usitwislave.c **** 		}
 400:usitwislave.c **** 
 401:usitwislave.c **** 		if(call_datacallback)
 800               	.LM105:
 801               	/* #NOAPP */
 802 02de 8823      		tst r24
 803 02e0 01F4      		brne .+2
 804 02e2 00C0      		rjmp .L54
 402:usitwislave.c **** 		{
 403:usitwislave.c **** 			output_buffer_length	= 0;
 806               	.LM106:
 807 02e4 1092 0000 		sts output_buffer_length,__zero_reg__
 404:usitwislave.c **** 			output_buffer_current	= 0;
 809               	.LM107:
 810 02e8 1092 0000 		sts output_buffer_current,__zero_reg__
 405:usitwislave.c **** 			data_callback(&input_buffer_length, &input_buffer, &output_buffer_length, &output_buffer);
 812               	.LM108:
 813 02ec E091 0000 		lds r30,data_callback
 814 02f0 F091 0000 		lds r31,data_callback+1
 815 02f4 20E0      		ldi r18,lo8(output_buffer)
 816 02f6 30E0      		ldi r19,hi8(output_buffer)
 817 02f8 40E0      		ldi r20,lo8(output_buffer_length)
 818 02fa 50E0      		ldi r21,hi8(output_buffer_length)
 819 02fc 60E0      		ldi r22,lo8(input_buffer)
 820 02fe 70E0      		ldi r23,hi8(input_buffer)
 821 0300 80E0      		ldi r24,lo8(input_buffer_length)
 822 0302 90E0      		ldi r25,hi8(input_buffer_length)
 823 0304 0995      		icall
 406:usitwislave.c **** 			input_buffer_length		= 0;
 825               	.LM109:
 826 0306 1092 0000 		sts input_buffer_length,__zero_reg__
 827 030a 00C0      		rjmp .L54
 832               	.Lscope6:
 834               		.stabd	78,0,0
 837               	.global	usi_twi_enable_stats
 839               	usi_twi_enable_stats:
 840               		.stabd	46,0,0
 407:usitwislave.c **** 			call_datacallback		= 0;
 408:usitwislave.c **** 		}
 409:usitwislave.c **** 	}
 410:usitwislave.c **** }
 411:usitwislave.c **** 
 412:usitwislave.c **** void usi_twi_enable_stats(uint8_t onoff)
 413:usitwislave.c **** {
 842               	.LM110:
 843               	.LFBB7:
 844               	/* prologue: function */
 845               	/* frame size = 0 */
 846               	/* stack size = 0 */
 847               	.L__stack_usage = 0
 414:usitwislave.c **** 	stats_enabled				= onoff;
 849               	.LM111:
 850 030c 8093 0000 		sts stats_enabled,r24
 415:usitwislave.c **** 	start_conditions_count		= 0;
 852               	.LM112:
 853 0310 1092 0000 		sts start_conditions_count+1,__zero_reg__
 854 0314 1092 0000 		sts start_conditions_count,__zero_reg__
 416:usitwislave.c **** 	stop_conditions_count		= 0;
 856               	.LM113:
 857 0318 1092 0000 		sts stop_conditions_count+1,__zero_reg__
 858 031c 1092 0000 		sts stop_conditions_count,__zero_reg__
 417:usitwislave.c **** 	error_conditions_count		= 0;
 860               	.LM114:
 861 0320 1092 0000 		sts error_conditions_count+1,__zero_reg__
 862 0324 1092 0000 		sts error_conditions_count,__zero_reg__
 418:usitwislave.c **** 	overflow_conditions_count	= 0;
 864               	.LM115:
 865 0328 1092 0000 		sts overflow_conditions_count+1,__zero_reg__
 866 032c 1092 0000 		sts overflow_conditions_count,__zero_reg__
 419:usitwislave.c **** 	local_frames_count			= 0;
 868               	.LM116:
 869 0330 1092 0000 		sts local_frames_count+1,__zero_reg__
 870 0334 1092 0000 		sts local_frames_count,__zero_reg__
 420:usitwislave.c **** 	idle_call_count				= 0;
 872               	.LM117:
 873 0338 1092 0000 		sts idle_call_count+1,__zero_reg__
 874 033c 1092 0000 		sts idle_call_count,__zero_reg__
 875 0340 0895      		ret
 877               	.Lscope7:
 879               		.stabd	78,0,0
 881               	.global	usi_twi_stats_start_conditions
 883               	usi_twi_stats_start_conditions:
 884               		.stabd	46,0,0
 421:usitwislave.c **** }
 422:usitwislave.c **** 
 423:usitwislave.c **** uint16_t usi_twi_stats_start_conditions(void)
 424:usitwislave.c **** {
 886               	.LM118:
 887               	.LFBB8:
 888               	/* prologue: function */
 889               	/* frame size = 0 */
 890               	/* stack size = 0 */
 891               	.L__stack_usage = 0
 425:usitwislave.c **** 	return(start_conditions_count);
 426:usitwislave.c **** }
 893               	.LM119:
 894 0342 8091 0000 		lds r24,start_conditions_count
 895 0346 9091 0000 		lds r25,start_conditions_count+1
 896 034a 0895      		ret
 898               	.Lscope8:
 900               		.stabd	78,0,0
 902               	.global	usi_twi_stats_stop_conditions
 904               	usi_twi_stats_stop_conditions:
 905               		.stabd	46,0,0
 427:usitwislave.c **** 
 428:usitwislave.c **** uint16_t usi_twi_stats_stop_conditions(void)
 429:usitwislave.c **** {
 907               	.LM120:
 908               	.LFBB9:
 909               	/* prologue: function */
 910               	/* frame size = 0 */
 911               	/* stack size = 0 */
 912               	.L__stack_usage = 0
 430:usitwislave.c **** 	return(stop_conditions_count);
 431:usitwislave.c **** }
 914               	.LM121:
 915 034c 8091 0000 		lds r24,stop_conditions_count
 916 0350 9091 0000 		lds r25,stop_conditions_count+1
 917 0354 0895      		ret
 919               	.Lscope9:
 921               		.stabd	78,0,0
 923               	.global	usi_twi_stats_error_conditions
 925               	usi_twi_stats_error_conditions:
 926               		.stabd	46,0,0
 432:usitwislave.c **** 
 433:usitwislave.c **** uint16_t usi_twi_stats_error_conditions(void)
 434:usitwislave.c **** {
 928               	.LM122:
 929               	.LFBB10:
 930               	/* prologue: function */
 931               	/* frame size = 0 */
 932               	/* stack size = 0 */
 933               	.L__stack_usage = 0
 435:usitwislave.c **** 	return(error_conditions_count);
 436:usitwislave.c **** }
 935               	.LM123:
 936 0356 8091 0000 		lds r24,error_conditions_count
 937 035a 9091 0000 		lds r25,error_conditions_count+1
 938 035e 0895      		ret
 940               	.Lscope10:
 942               		.stabd	78,0,0
 944               	.global	usi_twi_stats_overflow_conditions
 946               	usi_twi_stats_overflow_conditions:
 947               		.stabd	46,0,0
 437:usitwislave.c **** 
 438:usitwislave.c **** uint16_t usi_twi_stats_overflow_conditions(void)
 439:usitwislave.c **** {
 949               	.LM124:
 950               	.LFBB11:
 951               	/* prologue: function */
 952               	/* frame size = 0 */
 953               	/* stack size = 0 */
 954               	.L__stack_usage = 0
 440:usitwislave.c **** 	return(overflow_conditions_count);
 441:usitwislave.c **** }
 956               	.LM125:
 957 0360 8091 0000 		lds r24,overflow_conditions_count
 958 0364 9091 0000 		lds r25,overflow_conditions_count+1
 959 0368 0895      		ret
 961               	.Lscope11:
 963               		.stabd	78,0,0
 965               	.global	usi_twi_stats_local_frames
 967               	usi_twi_stats_local_frames:
 968               		.stabd	46,0,0
 442:usitwislave.c **** 
 443:usitwislave.c **** uint16_t usi_twi_stats_local_frames(void)
 444:usitwislave.c **** {
 970               	.LM126:
 971               	.LFBB12:
 972               	/* prologue: function */
 973               	/* frame size = 0 */
 974               	/* stack size = 0 */
 975               	.L__stack_usage = 0
 445:usitwislave.c **** 	return(local_frames_count);
 446:usitwislave.c **** }
 977               	.LM127:
 978 036a 8091 0000 		lds r24,local_frames_count
 979 036e 9091 0000 		lds r25,local_frames_count+1
 980 0372 0895      		ret
 982               	.Lscope12:
 984               		.stabd	78,0,0
 986               	.global	usi_twi_stats_idle_calls
 988               	usi_twi_stats_idle_calls:
 989               		.stabd	46,0,0
 447:usitwislave.c **** 
 448:usitwislave.c **** uint16_t usi_twi_stats_idle_calls(void)
 449:usitwislave.c **** {
 991               	.LM128:
 992               	.LFBB13:
 993               	/* prologue: function */
 994               	/* frame size = 0 */
 995               	/* stack size = 0 */
 996               	.L__stack_usage = 0
 450:usitwislave.c **** 	return(idle_call_count);
 451:usitwislave.c **** }
 998               	.LM129:
 999 0374 8091 0000 		lds r24,idle_call_count
 1000 0378 9091 0000 		lds r25,idle_call_count+1
 1001 037c 0895      		ret
 1003               	.Lscope13:
 1005               		.stabd	78,0,0
 1006               		.local	idle_call_count
 1007               		.comm	idle_call_count,2,1
 1008               		.local	local_frames_count
 1009               		.comm	local_frames_count,2,1
 1010               		.local	overflow_conditions_count
 1011               		.comm	overflow_conditions_count,2,1
 1012               		.local	error_conditions_count
 1013               		.comm	error_conditions_count,2,1
 1014               		.local	stop_conditions_count
 1015               		.comm	stop_conditions_count,2,1
 1016               		.local	start_conditions_count
 1017               		.comm	start_conditions_count,2,1
 1018               		.local	stats_enabled
 1019               		.comm	stats_enabled,1,1
 1020               		.local	output_buffer_current
 1021               		.comm	output_buffer_current,1,1
 1022               		.local	output_buffer_length
 1023               		.comm	output_buffer_length,1,1
 1024               		.local	output_buffer
 1025               		.comm	output_buffer,32,1
 1026               		.local	input_buffer_length
 1027               		.comm	input_buffer_length,1,1
 1028               		.local	input_buffer
 1029               		.comm	input_buffer,32,1
 1030               		.local	slave_address
 1031               		.comm	slave_address,1,1
 1032               		.local	ss_state
 1033               		.comm	ss_state,1,1
 1034               		.local	of_state
 1035               		.comm	of_state,1,1
 1036               		.local	data_callback
 1037               		.comm	data_callback,2,1
 1038               		.local	idle_callback
 1039               		.comm	idle_callback,2,1
 1040               		.comm	startstop_state_t,1,1
 1041               		.comm	overflow_state_t,1,1
 1062               	.Letext0:
 1063               		.ident	"GCC: (GNU) 5.2.0"
 1064               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 usitwislave.c
     /tmp/ccSnqoOf.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccSnqoOf.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccSnqoOf.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccSnqoOf.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccSnqoOf.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccSnqoOf.s:111    .text:0000000000000000 set_sda_to_input
     /tmp/ccSnqoOf.s:130    .text:0000000000000004 set_sda_to_output
     /tmp/ccSnqoOf.s:149    .text:0000000000000008 twi_reset
     /tmp/ccSnqoOf.s:236    .text:0000000000000026 __vector_15
     /tmp/ccSnqoOf.s:1017   .bss:000000000000000c stats_enabled
     /tmp/ccSnqoOf.s:1011   .bss:0000000000000006 error_conditions_count
     /tmp/ccSnqoOf.s:1015   .bss:000000000000000a start_conditions_count
     /tmp/ccSnqoOf.s:1033   .bss:0000000000000052 of_state
     /tmp/ccSnqoOf.s:1031   .bss:0000000000000051 ss_state
     /tmp/ccSnqoOf.s:355    .text:00000000000000c6 __vector_16
     /tmp/ccSnqoOf.s:1009   .bss:0000000000000004 overflow_conditions_count
     /tmp/ccSnqoOf.s:1029   .bss:0000000000000050 slave_address
     /tmp/ccSnqoOf.s:1019   .bss:000000000000000d output_buffer_current
     /tmp/ccSnqoOf.s:1021   .bss:000000000000000e output_buffer_length
     /tmp/ccSnqoOf.s:1023   .bss:000000000000000f output_buffer
     /tmp/ccSnqoOf.s:1025   .bss:000000000000002f input_buffer_length
     /tmp/ccSnqoOf.s:1027   .bss:0000000000000030 input_buffer
     /tmp/ccSnqoOf.s:622    .text:000000000000020c usi_twi_slave
     /tmp/ccSnqoOf.s:1035   .bss:0000000000000053 data_callback
     /tmp/ccSnqoOf.s:1037   .bss:0000000000000055 idle_callback
                             .bss:0000000000000000 idle_call_count
     /tmp/ccSnqoOf.s:1013   .bss:0000000000000008 stop_conditions_count
     /tmp/ccSnqoOf.s:1007   .bss:0000000000000002 local_frames_count
     /tmp/ccSnqoOf.s:839    .text:000000000000030c usi_twi_enable_stats
     /tmp/ccSnqoOf.s:883    .text:0000000000000342 usi_twi_stats_start_conditions
     /tmp/ccSnqoOf.s:904    .text:000000000000034c usi_twi_stats_stop_conditions
     /tmp/ccSnqoOf.s:925    .text:0000000000000356 usi_twi_stats_error_conditions
     /tmp/ccSnqoOf.s:946    .text:0000000000000360 usi_twi_stats_overflow_conditions
     /tmp/ccSnqoOf.s:967    .text:000000000000036a usi_twi_stats_local_frames
     /tmp/ccSnqoOf.s:988    .text:0000000000000374 usi_twi_stats_idle_calls
                            *COM*:0000000000000001 startstop_state_t
                            *COM*:0000000000000001 overflow_state_t

UNDEFINED SYMBOLS
__do_clear_bss
