   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   9               		.text
  10               	.Ltext0:
 110               	.global	twi_callback
 112               	twi_callback:
 113               		.stabd	46,0,0
   1:main.c        **** /*
   2:main.c        **** * Hackaday.com AVR Tutorial firmware
   3:main.c        **** * written by: Mike Szczys (@szczys)
   4:main.c        **** * 10/24/2010
   5:main.c        **** *
   6:main.c        **** * ATmega168
   7:main.c        **** * Blinks one LED conneced to PD0
   8:main.c        **** *
   9:main.c        **** * http://hackaday.com/2010/10/25/avr-programming-02-the-hardware/
  10:main.c        **** */
  11:main.c        **** #define __AVR_ATtiny84A__
  12:main.c        **** 
  13:main.c        **** #define F_CPU 8000000
  14:main.c        **** #include <avr/io.h>
  15:main.c        **** #include <avr/interrupt.h>
  16:main.c        **** #include <stdint.h>
  17:main.c        **** #include "usitwislave.h"
  18:main.c        **** 
  19:main.c        **** #include <util/delay.h>
  20:main.c        **** #include "cw.h"
  21:main.c        **** 
  22:main.c        **** 
  23:main.c        **** volatile uint8_t *i2cOutBuf;
  24:main.c        **** volatile const uint8_t *i2cInBuf;
  25:main.c        **** volatile uint8_t *i2cInLen;
  26:main.c        **** volatile uint8_t *i2cOutLen;
  27:main.c        **** char v[2];
  28:main.c        **** char cur[2];
  29:main.c        **** char temp[2];
  30:main.c        **** 
  31:main.c        **** 
  32:main.c        **** 
  33:main.c        **** void twi_callback(volatile uint8_t *input_buffer_length, 
  34:main.c        **** 		volatile const uint8_t *input_buffer, volatile uint8_t *output_buffer_length, 
  35:main.c        **** 		volatile uint8_t *output_buffer) {
 115               	.LM0:
 116               	.LFBB1:
 117               	/* prologue: function */
 118               	/* frame size = 0 */
 119               	/* stack size = 0 */
 120               	.L__stack_usage = 0
 121 0000 F901      		movw r30,r18
  36:main.c        **** 	/*PORTB ^= (1<<2);        //Use xor to toggle the LED*/
  37:main.c        **** 	i2cOutLen = output_buffer_length;
 123               	.LM1:
 124 0002 5093 0000 		sts i2cOutLen+1,r21
 125 0006 4093 0000 		sts i2cOutLen,r20
  38:main.c        **** 	i2cOutBuf = output_buffer;
 127               	.LM2:
 128 000a 3093 0000 		sts i2cOutBuf+1,r19
 129 000e 2093 0000 		sts i2cOutBuf,r18
  39:main.c        **** 	i2cInLen = input_buffer_length;
 131               	.LM3:
 132 0012 9093 0000 		sts i2cInLen+1,r25
 133 0016 8093 0000 		sts i2cInLen,r24
  40:main.c        **** 	i2cInBuf = input_buffer;
 135               	.LM4:
 136 001a 7093 0000 		sts i2cInBuf+1,r23
 137 001e 6093 0000 		sts i2cInBuf,r22
  41:main.c        **** 			switch (*i2cInBuf){
 139               	.LM5:
 140 0022 DB01      		movw r26,r22
 141 0024 8C91      		ld r24,X
 142 0026 8330      		cpi r24,lo8(3)
 143 0028 01F0      		breq .L3
 144 002a 8430      		cpi r24,lo8(4)
 145 002c 01F0      		breq .L4
 146 002e 8230      		cpi r24,lo8(2)
 147 0030 01F4      		brne .L1
 148               	.LBB4:
 149               	.LBB5:
  42:main.c        **** 				case (1):
  43:main.c        **** 					{
  44:main.c        **** 						break;
  45:main.c        **** 					}
  46:main.c        **** 				case (2):
  47:main.c        **** 					{
  48:main.c        **** 						// Voltage request. 
  49:main.c        **** 						i2cOutBuf[0] = v[0]++;
 151               	.LM6:
 152 0032 9091 0000 		lds r25,v
 153 0036 21E0      		ldi r18,lo8(1)
 154 0038 290F      		add r18,r25
 155 003a 2093 0000 		sts v,r18
 156 003e 9083      		st Z,r25
  50:main.c        **** 						i2cOutBuf[1] = v[1]++;
 158               	.LM7:
 159 0040 E091 0000 		lds r30,i2cOutBuf
 160 0044 F091 0000 		lds r31,i2cOutBuf+1
 161 0048 9091 0000 		lds r25,v+1
 162 004c 21E0      		ldi r18,lo8(1)
 163 004e 290F      		add r18,r25
 164 0050 2093 0000 		sts v+1,r18
 165 0054 9183      		std Z+1,r25
  51:main.c        **** 						*i2cOutLen = 2;
 167               	.LM8:
 168 0056 E091 0000 		lds r30,i2cOutLen
 169 005a F091 0000 		lds r31,i2cOutLen+1
 170 005e 00C0      		rjmp .L6
 171               	.L3:
 172               	.LBE5:
 173               	.LBE4:
  52:main.c        **** 						break;
  53:main.c        **** 					}
  54:main.c        **** 				case (3):
  55:main.c        **** 					{
  56:main.c        **** 						i2cOutBuf[0] = cur[0];
 175               	.LM9:
 176 0060 8091 0000 		lds r24,cur
 177 0064 8083      		st Z,r24
  57:main.c        **** 						i2cOutBuf[1] = cur[1];
 179               	.LM10:
 180 0066 E091 0000 		lds r30,i2cOutBuf
 181 006a F091 0000 		lds r31,i2cOutBuf+1
 182 006e 8091 0000 		lds r24,cur+1
 183 0072 00C0      		rjmp .L7
 184               	.L4:
  58:main.c        **** 						*i2cOutLen = 2;
  59:main.c        **** 						break;
  60:main.c        **** 					}
  61:main.c        **** 				case (4):
  62:main.c        **** 					{
  63:main.c        **** 						i2cOutBuf[0] = temp[0];
 186               	.LM11:
 187 0074 8091 0000 		lds r24,temp
 188 0078 8083      		st Z,r24
  64:main.c        **** 						i2cOutBuf[1] = temp[1];
 190               	.LM12:
 191 007a E091 0000 		lds r30,i2cOutBuf
 192 007e F091 0000 		lds r31,i2cOutBuf+1
 193 0082 8091 0000 		lds r24,temp+1
 194               	.L7:
 195 0086 8183      		std Z+1,r24
  65:main.c        **** 						*i2cOutLen = 2;
 197               	.LM13:
 198 0088 E091 0000 		lds r30,i2cOutLen
 199 008c F091 0000 		lds r31,i2cOutLen+1
 200 0090 82E0      		ldi r24,lo8(2)
 201               	.L6:
 202 0092 8083      		st Z,r24
 203               	.L1:
 204 0094 0895      		ret
 206               	.Lscope1:
 208               		.stabd	78,0,0
 210               	.global	adcVinInit
 212               	adcVinInit:
 213               		.stabd	46,0,0
  66:main.c        **** 						break;
  67:main.c        **** 					}
  68:main.c        **** 			}
  69:main.c        **** }
  70:main.c        **** 
  71:main.c        **** 
  72:main.c        **** 
  73:main.c        **** 
  74:main.c        **** void adcVinInit(void){
 215               	.LM14:
 216               	.LFBB2:
 217               	/* prologue: function */
 218               	/* frame size = 0 */
 219               	/* stack size = 0 */
 220               	.L__stack_usage = 0
  75:main.c        **** 	// For right now, will set up for single ended, battery voltage measurement. 
  76:main.c        **** 	//
  77:main.c        **** 	PRR &= ~(1 << PRADC);
 222               	.LM15:
 223 0096 0098      		cbi 0,0
  78:main.c        **** 	ADCSRA &= ~(1 << ADEN);
 225               	.LM16:
 226 0098 3798      		cbi 0x6,7
  79:main.c        **** 	ADMUX = 0;
 228               	.LM17:
 229 009a 17B8      		out 0x7,__zero_reg__
  80:main.c        **** 
  81:main.c        **** 	ADCSRB = (1 << ADLAR) ;
 231               	.LM18:
 232 009c 80E1      		ldi r24,lo8(16)
 233 009e 83B9      		out 0x3,r24
  82:main.c        **** 	ADCSRA = (0x6) | (1 << ADEN);
 235               	.LM19:
 236 00a0 86E8      		ldi r24,lo8(-122)
 237 00a2 86B9      		out 0x6,r24
 238 00a4 0895      		ret
 240               	.Lscope2:
 242               		.stabd	78,0,0
 244               	.global	measVin
 246               	measVin:
 247               		.stabd	46,0,0
  83:main.c        **** }
  84:main.c        **** int measVin(void) {
 249               	.LM20:
 250               	.LFBB3:
 251               	/* prologue: function */
 252               	/* frame size = 0 */
 253               	/* stack size = 0 */
 254               	.L__stack_usage = 0
 255               	.L11:
  85:main.c        **** 	int temp;
  86:main.c        **** 	while ( ADCSRA & (1 << ADSC));
 257               	.LM21:
 258 00a6 3699      		sbic 0x6,6
 259 00a8 00C0      		rjmp .L11
  87:main.c        **** 	adcVinInit();
 261               	.LM22:
 262 00aa 00D0      		rcall adcVinInit
  88:main.c        **** 	ADCSRA |= (1 << ADSC);
 264               	.LM23:
 265 00ac 369A      		sbi 0x6,6
 266               	.L12:
  89:main.c        **** 	while ( ADCSRA & (1 << ADSC));
 268               	.LM24:
 269 00ae 3699      		sbic 0x6,6
 270 00b0 00C0      		rjmp .L12
  90:main.c        **** 	/*v[0] = ADCH;*/
  91:main.c        **** 	/*v[1] = ADCL;*/
  92:main.c        **** 	if (v[0] == 0x00){
 272               	.LM25:
 273 00b2 8091 0000 		lds r24,v
 274 00b6 8111      		cpse r24,__zero_reg__
 275 00b8 00C0      		rjmp .L13
 276               	.LBB8:
  93:main.c        **** 		PORTB ^= (1<<2);        //Use xor to toggle the LED
 278               	.LM26:
 279 00ba 98B3      		in r25,0x18
 280 00bc 84E0      		ldi r24,lo8(4)
 281 00be 8927      		eor r24,r25
 282 00c0 88BB      		out 0x18,r24
 283               	.L13:
 284               	.LBE8:
  94:main.c        **** 	}
  95:main.c        **** }
 286               	.LM27:
 287 00c2 0895      		ret
 289               	.Lscope3:
 291               		.stabd	78,0,0
 293               	.global	adcCurInit
 295               	adcCurInit:
 296               		.stabd	46,0,0
  96:main.c        **** 
  97:main.c        **** void adcCurInit(void){
 298               	.LM28:
 299               	.LFBB4:
 300               	/* prologue: function */
 301               	/* frame size = 0 */
 302               	/* stack size = 0 */
 303               	.L__stack_usage = 0
  98:main.c        **** 	// For right now, will set up for single ended, battery voltage measurement. 
  99:main.c        **** 	// PA1 is pos
 100:main.c        **** 	// PA2 is neg
 101:main.c        **** 	//
 102:main.c        **** 	PRR &= ~(1 << PRADC);
 305               	.LM29:
 306 00c4 0098      		cbi 0,0
 103:main.c        **** 	ADCSRA &= ~(1 << ADEN);
 308               	.LM30:
 309 00c6 3798      		cbi 0x6,7
 104:main.c        **** 	ADMUX = 0x0d;
 311               	.LM31:
 312 00c8 8DE0      		ldi r24,lo8(13)
 313 00ca 87B9      		out 0x7,r24
 105:main.c        **** 
 106:main.c        **** 	ADCSRB = (1 << ADLAR) ;
 315               	.LM32:
 316 00cc 80E1      		ldi r24,lo8(16)
 317 00ce 83B9      		out 0x3,r24
 107:main.c        **** 	ADCSRA = (0x6) | (1 << ADEN);
 319               	.LM33:
 320 00d0 86E8      		ldi r24,lo8(-122)
 321 00d2 86B9      		out 0x6,r24
 322 00d4 0895      		ret
 324               	.Lscope4:
 326               		.stabd	78,0,0
 328               	.global	measCur
 330               	measCur:
 331               		.stabd	46,0,0
 108:main.c        **** }
 109:main.c        **** int measCur(void) {
 333               	.LM34:
 334               	.LFBB5:
 335               	/* prologue: function */
 336               	/* frame size = 0 */
 337               	/* stack size = 0 */
 338               	.L__stack_usage = 0
 339               	.L18:
 110:main.c        **** 	int temp;
 111:main.c        **** 	while ( ADCSRA & (1 << ADSC));
 341               	.LM35:
 342 00d6 3699      		sbic 0x6,6
 343 00d8 00C0      		rjmp .L18
 112:main.c        **** 	adcCurInit();
 345               	.LM36:
 346 00da 00D0      		rcall adcCurInit
 113:main.c        **** 	ADCSRA |= (1 << ADSC);
 348               	.LM37:
 349 00dc 369A      		sbi 0x6,6
 350               	.L19:
 114:main.c        **** 	while ( ADCSRA & (1 << ADSC));
 352               	.LM38:
 353 00de 3699      		sbic 0x6,6
 354 00e0 00C0      		rjmp .L19
 115:main.c        **** 	cur[0] = ADCH;
 356               	.LM39:
 357 00e2 85B1      		in r24,0x5
 358 00e4 8093 0000 		sts cur,r24
 116:main.c        **** 	cur[1] = ADCL;
 360               	.LM40:
 361 00e8 84B1      		in r24,0x4
 362 00ea 8093 0000 		sts cur+1,r24
 117:main.c        **** }
 364               	.LM41:
 365 00ee 0895      		ret
 367               	.Lscope5:
 369               		.stabd	78,0,0
 370               		.section	.rodata.str1.1,"aMS",@progbits,1
 371               	.LC0:
 372 0000 4142 3154 		.string	"AB1TJ"
 372      4A00 
 373               		.section	.text.startup,"ax",@progbits
 375               	.global	main
 377               	main:
 378               		.stabd	46,0,0
 118:main.c        **** 
 119:main.c        **** 
 120:main.c        **** int main(void)
 121:main.c        **** {
 380               	.LM42:
 381               	.LFBB6:
 382               	/* prologue: function */
 383               	/* frame size = 0 */
 384               	/* stack size = 0 */
 385               	.L__stack_usage = 0
 122:main.c        **** 
 123:main.c        **** 	int i;
 124:main.c        **** 	/*for (i=0;i<7;i++){*/
 125:main.c        **** 	/*DDRB |= (1<<i);     //Set PortD Pin0 as an output*/
 126:main.c        **** 	/*DDRA |= (1<<i);     //Set PortD Pin0 as an output*/
 127:main.c        **** 	/*PORTB |= (1<<i);        //Set PortD Pin0 high to turn on LED*/
 128:main.c        **** 	/*PORTA |= (1<<i);        //Set PortD Pin0 high to turn on LED*/
 129:main.c        **** 	/*}*/
 130:main.c        **** 	DDRB |= (1<<2) | 1;
 387               	.LM43:
 388 0000 87B3      		in r24,0x17
 389 0002 8560      		ori r24,lo8(5)
 390 0004 87BB      		out 0x17,r24
 131:main.c        **** 	DDRA |= (1<<7);
 392               	.LM44:
 393 0006 D79A      		sbi 0x1a,7
 132:main.c        **** 	measCur();
 395               	.LM45:
 396 0008 00D0      		rcall measCur
 133:main.c        **** 	measVin();	
 398               	.LM46:
 399 000a 00D0      		rcall measVin
 134:main.c        **** 	// Set PTB0 to 0 to enable power save. 
 135:main.c        **** 	/*PORTB &= ~(1<<0);*/
 136:main.c        **** 	cwSend("AB1TJ", 5);
 401               	.LM47:
 402 000c 65E0      		ldi r22,lo8(5)
 403 000e 70E0      		ldi r23,0
 404 0010 80E0      		ldi r24,lo8(.LC0)
 405 0012 90E0      		ldi r25,hi8(.LC0)
 406 0014 00D0      		rcall cwSend
 137:main.c        **** 
 138:main.c        **** 	/*PORTB ^= (1<<2);*/
 139:main.c        **** 	//Setup the clock
 140:main.c        **** 	TCCR1B |= (1 << WGM12) | 1<<CS11 | 1<<CS10;  //Divide by 64
 408               	.LM48:
 409 0016 8EB5      		in r24,0x2e
 410 0018 8B60      		ori r24,lo8(11)
 411 001a 8EBD      		out 0x2e,r24
 141:main.c        **** 	OCR1A = 5000;        //Count 15624 cycles for 1 second interrupt
 413               	.LM49:
 414 001c 88E8      		ldi r24,lo8(-120)
 415 001e 93E1      		ldi r25,lo8(19)
 416 0020 9BBD      		out 0x2a+1,r25
 417 0022 8ABD      		out 0x2a,r24
 142:main.c        **** 	/*OCR1A = 15624;        //Count 15624 cycles for 1 second interrupt*/
 143:main.c        **** 	TIMSK1 |= 1<<OCIE1A;        //enable timer compare interrupt
 419               	.LM50:
 420 0024 619A      		sbi 0xc,1
 144:main.c        **** 	sei();            //Enable global interrupts
 422               	.LM51:
 423               	/* #APP */
 424               	 ;  144 "main.c" 1
 425 0026 7894      		sei
 426               	 ;  0 "" 2
 145:main.c        **** 
 146:main.c        **** 	usi_twi_slave(0x68, 1, twi_callback, 0);
 428               	.LM52:
 429               	/* #NOAPP */
 430 0028 20E0      		ldi r18,0
 431 002a 30E0      		ldi r19,0
 432 002c 40E0      		ldi r20,lo8(gs(twi_callback))
 433 002e 50E0      		ldi r21,hi8(gs(twi_callback))
 434 0030 61E0      		ldi r22,lo8(1)
 435 0032 88E6      		ldi r24,lo8(104)
 436 0034 00D0      		rcall usi_twi_slave
 147:main.c        **** 
 148:main.c        **** 	cwSend("AB1TJ", 5);
 438               	.LM53:
 439 0036 65E0      		ldi r22,lo8(5)
 440 0038 70E0      		ldi r23,0
 441 003a 80E0      		ldi r24,lo8(.LC0)
 442 003c 90E0      		ldi r25,hi8(.LC0)
 443 003e 00D0      		rcall cwSend
 149:main.c        **** 	for(;;){
 150:main.c        **** 		if (*i2cInLen){
 445               	.LM54:
 446 0040 E091 0000 		lds r30,i2cInLen
 447 0044 F091 0000 		lds r31,i2cInLen+1
 448               	.L23:
 449 0048 8081      		ld r24,Z
 151:main.c        **** 
 152:main.c        **** 		}
 153:main.c        **** 	}
 451               	.LM55:
 452 004a 00C0      		rjmp .L23
 454               	.Lscope6:
 456               		.stabd	78,0,0
 457               		.text
 459               	.global	__vector_6
 461               	__vector_6:
 462               		.stabd	46,0,0
 154:main.c        **** }
 155:main.c        **** 
 156:main.c        **** ISR (TIM1_COMPA_vect)      //Interrupt Service Routine
 157:main.c        **** {
 464               	.LM56:
 465               	.LFBB7:
 466 00f0 1F92      		push r1
 467 00f2 0F92      		push r0
 468 00f4 0FB6      		in r0,__SREG__
 469 00f6 0F92      		push r0
 470 00f8 1124      		clr __zero_reg__
 471 00fa 2F93      		push r18
 472 00fc 3F93      		push r19
 473 00fe 4F93      		push r20
 474 0100 5F93      		push r21
 475 0102 6F93      		push r22
 476 0104 7F93      		push r23
 477 0106 8F93      		push r24
 478 0108 9F93      		push r25
 479 010a AF93      		push r26
 480 010c BF93      		push r27
 481 010e EF93      		push r30
 482 0110 FF93      		push r31
 483               	/* prologue: Signal */
 484               	/* frame size = 0 */
 485               	/* stack size = 15 */
 486               	.L__stack_usage = 15
 158:main.c        **** 	PORTA ^= (1<<7);        //Use xor to toggle the LED
 488               	.LM57:
 489 0112 8BB3      		in r24,0x1b
 490 0114 8058      		subi r24,lo8(-(-128))
 491 0116 8BBB      		out 0x1b,r24
 159:main.c        **** 	measCur();
 493               	.LM58:
 494 0118 00D0      		rcall measCur
 160:main.c        **** 	measVin();	
 496               	.LM59:
 497 011a 00D0      		rcall measVin
 498               	/* epilogue start */
 161:main.c        **** }
 500               	.LM60:
 501 011c FF91      		pop r31
 502 011e EF91      		pop r30
 503 0120 BF91      		pop r27
 504 0122 AF91      		pop r26
 505 0124 9F91      		pop r25
 506 0126 8F91      		pop r24
 507 0128 7F91      		pop r23
 508 012a 6F91      		pop r22
 509 012c 5F91      		pop r21
 510 012e 4F91      		pop r20
 511 0130 3F91      		pop r19
 512 0132 2F91      		pop r18
 513 0134 0F90      		pop r0
 514 0136 0FBE      		out __SREG__,r0
 515 0138 0F90      		pop r0
 516 013a 1F90      		pop r1
 517 013c 1895      		reti
 519               	.Lscope7:
 521               		.stabd	78,0,0
 522               		.comm	temp,2,1
 523               		.comm	cur,2,1
 524               		.comm	v,2,1
 525               		.comm	i2cOutLen,2,1
 526               		.comm	i2cInLen,2,1
 527               		.comm	i2cInBuf,2,1
 528               		.comm	i2cOutBuf,2,1
 537               	.Letext0:
 538               		.ident	"GCC: (GNU) 4.9.2 20141224 (prerelease)"
 539               	.global __do_copy_data
 540               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccYSBkbR.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccYSBkbR.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccYSBkbR.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccYSBkbR.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccYSBkbR.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccYSBkbR.s:112    .text:0000000000000000 twi_callback
                            *COM*:0000000000000002 i2cOutLen
                            *COM*:0000000000000002 i2cOutBuf
                            *COM*:0000000000000002 i2cInLen
                            *COM*:0000000000000002 i2cInBuf
                            *COM*:0000000000000002 v
                            *COM*:0000000000000002 cur
                            *COM*:0000000000000002 temp
     /tmp/ccYSBkbR.s:212    .text:0000000000000096 adcVinInit
     /tmp/ccYSBkbR.s:246    .text:00000000000000a6 measVin
     /tmp/ccYSBkbR.s:295    .text:00000000000000c4 adcCurInit
     /tmp/ccYSBkbR.s:330    .text:00000000000000d6 measCur
     /tmp/ccYSBkbR.s:377    .text.startup:0000000000000000 main
     /tmp/ccYSBkbR.s:461    .text:00000000000000f0 __vector_6

UNDEFINED SYMBOLS
cwSend
usi_twi_slave
__do_copy_data
__do_clear_bss
